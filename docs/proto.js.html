

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>Source: proto.js | Source: proto.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/bootstrap.min.css">
    <link type="text/css" rel="stylesheet" href="styles/prettify-jsdoc.css">
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/tui-doc.css">

    
</head>
<body>
<nav class="lnb" id="lnb">
    <div class="logo" style="width: 0px; height: 0px">
        <img src="img/toast-ui.png" width="100%" height="100%">
    </div>
    <div class="title">
        <h1><a href="index.html" class="link">Source: proto.js</a></h1>
        
    </div>
    <div class="search-container" id="search-container">
        <input type="text" placeholder="Search">
        <ul></ul>
    </div>
    
    <div class="lnb-api hidden"><h3>Modules</h3><ul><li><a href="module-@crabel_shared_csv.html">@crabel/shared/csv</a><button type="button" class="hidden toggle-subnav btn btn-link">  <span class="glyphicon glyphicon-plus"></span></button><div class="hidden" id="module:@crabel/shared/csv_sub"><div class="member-type">Methods</div><ul class="inner"><li><a href="module-@crabel_shared_csv.html#~csvToArray">csvToArray</a></li></ul></div></li><li><a href="module-@crabel_shared_file.html">@crabel/shared/file</a><button type="button" class="hidden toggle-subnav btn btn-link">  <span class="glyphicon glyphicon-plus"></span></button><div class="hidden" id="module:@crabel/shared/file_sub"><div class="member-type">Methods</div><ul class="inner"><li><a href="module-@crabel_shared_file.html#.addExt">addExt</a></li><li><a href="module-@crabel_shared_file.html#.copy">copy</a></li><li><a href="module-@crabel_shared_file.html#.ensurePath">ensurePath</a></li><li><a href="module-@crabel_shared_file.html#.erase">erase</a></li><li><a href="module-@crabel_shared_file.html#.loadText">loadText</a></li><li><a href="module-@crabel_shared_file.html#.makeUnique">makeUnique</a></li><li><a href="module-@crabel_shared_file.html#.move">move</a></li><li><a href="module-@crabel_shared_file.html#.removeExt">removeExt</a></li><li><a href="module-@crabel_shared_file.html#.saveText">saveText</a></li><li><a href="module-@crabel_shared_file.html#.swapExt">swapExt</a></li></ul></div></li><li><a href="module-@crabel_shared_Log.html">@crabel/shared/Log</a><button type="button" class="hidden toggle-subnav btn btn-link">  <span class="glyphicon glyphicon-plus"></span></button><div class="hidden" id="module:@crabel/shared/Log_sub"><div class="member-type">Typedef</div><ul class="inner"><li><a href="module-@crabel_shared_Log.html#~Column">Column</a></li><li><a href="module-@crabel_shared_Log.html#~Event">Event</a></li><li><a href="module-@crabel_shared_Log.html#~LogCallback">LogCallback</a></li><li><a href="module-@crabel_shared_Log.html#~LogOptions">LogOptions</a></li><li><a href="module-@crabel_shared_Log.html#~Table">Table</a></li></ul></div></li><li><a href="module-@crabel_shared_proto.html">@crabel/shared/proto</a><button type="button" class="hidden toggle-subnav btn btn-link">  <span class="glyphicon glyphicon-plus"></span></button><div class="hidden" id="module:@crabel/shared/proto_sub"><div class="member-type">Methods</div><ul class="inner"><li><a href="module-@crabel_shared_proto.html#.init">init</a></li></ul></div></li><li><a href="module-@crabel_shared_range.html">@crabel/shared/range</a><button type="button" class="hidden toggle-subnav btn btn-link">  <span class="glyphicon glyphicon-plus"></span></button><div class="hidden" id="module:@crabel/shared/range_sub"></div></li><li><a href="module-@crabel_shared_str_util.html">@crabel/shared/str_util</a><button type="button" class="hidden toggle-subnav btn btn-link">  <span class="glyphicon glyphicon-plus"></span></button><div class="hidden" id="module:@crabel/shared/str_util_sub"><div class="member-type">Methods</div><ul class="inner"><li><a href="module-@crabel_shared_str_util.html#.align">align</a></li><li><a href="module-@crabel_shared_str_util.html#.alignC">alignC</a></li><li><a href="module-@crabel_shared_str_util.html#.alignL">alignL</a></li><li><a href="module-@crabel_shared_str_util.html#.alignR">alignR</a></li><li><a href="module-@crabel_shared_str_util.html#.buildTable">buildTable</a></li><li><a href="module-@crabel_shared_str_util.html#.capitalize">capitalize</a></li><li><a href="module-@crabel_shared_str_util.html#.crc32">crc32</a></li><li><a href="module-@crabel_shared_str_util.html#.expand">expand</a></li><li><a href="module-@crabel_shared_str_util.html#.fill">fill</a></li><li><a href="module-@crabel_shared_str_util.html#.format">format</a></li><li><a href="module-@crabel_shared_str_util.html#.formatError">formatError</a></li><li><a href="module-@crabel_shared_str_util.html#.substDate">substDate</a></li><li><a href="module-@crabel_shared_str_util.html#.substEnv">substEnv</a></li><li><a href="module-@crabel_shared_str_util.html#.substProp">substProp</a></li><li><a href="module-@crabel_shared_str_util.html#.toObject">toObject</a></li></ul><div class="member-type">Typedef</div><ul class="inner"><li><a href="module-@crabel_shared_str_util.html#~FormatterCallback">FormatterCallback</a></li><li><a href="module-@crabel_shared_str_util.html#~ReviverCallback">ReviverCallback</a></li><li><a href="module-@crabel_shared_str_util.html#~SubstCallback">SubstCallback</a></li><li><a href="module-@crabel_shared_str_util.html#~TableColumn">TableColumn</a></li><li><a href="module-@crabel_shared_str_util.html#~TableSpecs">TableSpecs</a></li><li><a href="module-@crabel_shared_str_util.html#~Token">Token</a></li></ul></div></li></ul></div><div class="lnb-api hidden"><h3>Classes</h3><ul><li><a href="Array.html">Array</a><button type="button" class="hidden toggle-subnav btn btn-link">  <span class="glyphicon glyphicon-plus"></span></button><div class="hidden" id="Array_sub"><div class="member-type">Methods</div><ul class="inner"><li><a href="Array.html#empty">empty</a></li><li><a href="Array.html#first">first</a></li><li><a href="Array.html#isLast">isLast</a></li><li><a href="Array.html#last">last</a></li></ul></div></li><li><a href="Date.html">Date</a><button type="button" class="hidden toggle-subnav btn btn-link">  <span class="glyphicon glyphicon-plus"></span></button><div class="hidden" id="Date_sub"><div class="member-type">Methods</div><ul class="inner"><li><a href="Date.html#.format">format</a></li><li><a href="Date.html#.formatLength">formatLength</a></li><li><a href="Date.html#.sameDay">sameDay</a></li><li><a href="Date.html#addDays">addDays</a></li><li><a href="Date.html#addHours">addHours</a></li><li><a href="Date.html#addMillis">addMillis</a></li><li><a href="Date.html#addMinutes">addMinutes</a></li><li><a href="Date.html#addMonths">addMonths</a></li><li><a href="Date.html#addSeconds">addSeconds</a></li><li><a href="Date.html#addYears">addYears</a></li><li><a href="Date.html#diff">diff</a></li><li><a href="Date.html#earlierDayThan">earlierDayThan</a></li><li><a href="Date.html#format">format</a></li><li><a href="Date.html#incDay">incDay</a></li><li><a href="Date.html#incHour">incHour</a></li><li><a href="Date.html#incMilli">incMilli</a></li><li><a href="Date.html#incMinute">incMinute</a></li><li><a href="Date.html#incMonth">incMonth</a></li><li><a href="Date.html#incSecond">incSecond</a></li><li><a href="Date.html#incYear">incYear</a></li><li><a href="Date.html#laterDayThan">laterDayThan</a></li><li><a href="Date.html#sameDay">sameDay</a></li><li><a href="Date.html#toUtc">toUtc</a></li><li><a href="Date.html#truncTime">truncTime</a></li></ul></div></li><li><a href="module-@crabel_shared_csv-CsvReader.html">CsvReader</a><button type="button" class="hidden toggle-subnav btn btn-link">  <span class="glyphicon glyphicon-plus"></span></button><div class="hidden" id="module:@crabel/shared/csv~CsvReader_sub"><div class="member-type">Members</div><ul class="inner"><li><a href="module-@crabel_shared_csv-CsvReader.html#doc">doc</a></li><li><a href="module-@crabel_shared_csv-CsvReader.html#headers">headers</a></li></ul><div class="member-type">Methods</div><ul class="inner"><li><a href="module-@crabel_shared_csv-CsvReader.html#toString">toString</a></li></ul></div></li><li><a href="module-@crabel_shared_Log-Log.html">Log</a><button type="button" class="hidden toggle-subnav btn btn-link">  <span class="glyphicon glyphicon-plus"></span></button><div class="hidden" id="module:@crabel/shared/Log~Log_sub"><div class="member-type">Members</div><ul class="inner"><li><a href="module-@crabel_shared_Log-Log.html#.defEcho">defEcho</a></li><li><a href="module-@crabel_shared_Log-Log.html#.defHeader">defHeader</a></li><li><a href="module-@crabel_shared_Log-Log.html#.defLineWidth">defLineWidth</a></li><li><a href="module-@crabel_shared_Log-Log.html#.defMode">defMode</a></li><li><a href="module-@crabel_shared_Log-Log.html#.defTimeFormat">defTimeFormat</a></li><li><a href="module-@crabel_shared_Log-Log.html#.defTypeLabels">defTypeLabels</a></li><li><a href="module-@crabel_shared_Log-Log.html#.eventType">eventType</a></li><li><a href="module-@crabel_shared_Log-Log.html#.mode">mode</a></li><li><a href="module-@crabel_shared_Log-Log.html#active">active</a></li><li><a href="module-@crabel_shared_Log-Log.html#caption">caption</a></li><li><a href="module-@crabel_shared_Log-Log.html#echo">echo</a></li><li><a href="module-@crabel_shared_Log-Log.html#file">file</a></li><li><a href="module-@crabel_shared_Log-Log.html#fileName">fileName</a></li><li><a href="module-@crabel_shared_Log-Log.html#level">level</a></li><li><a href="module-@crabel_shared_Log-Log.html#lineWidth">lineWidth</a></li><li><a href="module-@crabel_shared_Log-Log.html#mode">mode</a></li><li><a href="module-@crabel_shared_Log-Log.html#name">name</a></li><li><a href="module-@crabel_shared_Log-Log.html#path">path</a></li><li><a href="module-@crabel_shared_Log-Log.html#pendingEvents">pendingEvents</a></li><li><a href="module-@crabel_shared_Log-Log.html#timeFormat">timeFormat</a></li><li><a href="module-@crabel_shared_Log-Log.html#typeLabels">typeLabels</a></li></ul><div class="member-type">Methods</div><ul class="inner"><li><a href="module-@crabel_shared_Log-Log.html#.err">err</a></li><li><a href="module-@crabel_shared_Log-Log.html#.eventTypeFromStr">eventTypeFromStr</a></li><li><a href="module-@crabel_shared_Log-Log.html#.getEvntTypeStr">getEvntTypeStr</a></li><li><a href="module-@crabel_shared_Log-Log.html#.getModeStr">getModeStr</a></li><li><a href="module-@crabel_shared_Log-Log.html#.info">info</a></li><li><a href="module-@crabel_shared_Log-Log.html#.levelFromStr">levelFromStr</a></li><li><a href="module-@crabel_shared_Log-Log.html#.makeLogFileName">makeLogFileName</a></li><li><a href="module-@crabel_shared_Log-Log.html#.modeFromStr">modeFromStr</a></li><li><a href="module-@crabel_shared_Log-Log.html#.out">out</a></li><li><a href="module-@crabel_shared_Log-Log.html#.setGlobal">setGlobal</a></li><li><a href="module-@crabel_shared_Log-Log.html#.trace">trace</a></li><li><a href="module-@crabel_shared_Log-Log.html#.warn">warn</a></li><li><a href="module-@crabel_shared_Log-Log.html#err">err</a></li><li><a href="module-@crabel_shared_Log-Log.html#info">info</a></li><li><a href="module-@crabel_shared_Log-Log.html#out">out</a></li><li><a href="module-@crabel_shared_Log-Log.html#shutdown">shutdown</a></li><li><a href="module-@crabel_shared_Log-Log.html#trace">trace</a></li><li><a href="module-@crabel_shared_Log-Log.html#warn">warn</a></li></ul></div></li><li><a href="module-@crabel_shared_range-ArrayRange.html">ArrayRange</a><button type="button" class="hidden toggle-subnav btn btn-link">  <span class="glyphicon glyphicon-plus"></span></button><div class="hidden" id="module:@crabel/shared/range~ArrayRange_sub"></div></li><li><a href="module-@crabel_shared_range-Range.html">Range</a><button type="button" class="hidden toggle-subnav btn btn-link">  <span class="glyphicon glyphicon-plus"></span></button><div class="hidden" id="module:@crabel/shared/range~Range_sub"><div class="member-type">Methods</div><ul class="inner"><li><a href="module-@crabel_shared_range-Range.html#add">add</a></li><li><a href="module-@crabel_shared_range-Range.html#clear">clear</a></li><li><a href="module-@crabel_shared_range-Range.html#combine">combine</a></li><li><a href="module-@crabel_shared_range-Range.html#empty">empty</a></li><li><a href="module-@crabel_shared_range-Range.html#exclude">exclude</a></li><li><a href="module-@crabel_shared_range-Range.html#forEach">forEach</a></li><li><a href="module-@crabel_shared_range-Range.html#from">from</a></li><li><a href="module-@crabel_shared_range-Range.html#inRange">inRange</a></li><li><a href="module-@crabel_shared_range-Range.html#intervalFromArray">intervalFromArray</a></li><li><a href="module-@crabel_shared_range-Range.html#same">same</a></li><li><a href="module-@crabel_shared_range-Range.html#subtract">subtract</a></li><li><a href="module-@crabel_shared_range-Range.html#to">to</a></li><li><a href="module-@crabel_shared_range-Range.html#toString">toString</a></li><li><a href="module-@crabel_shared_range-Range.html#validInterval">validInterval</a></li></ul></div></li><li><a href="Number.html">Number</a><button type="button" class="hidden toggle-subnav btn btn-link">  <span class="glyphicon glyphicon-plus"></span></button><div class="hidden" id="Number_sub"><div class="member-type">Methods</div><ul class="inner"><li><a href="Number.html#between">between</a></li><li><a href="Number.html#nextPow2">nextPow2</a></li><li><a href="Number.html#prevPow2">prevPow2</a></li><li><a href="Number.html#roundToInt">roundToInt</a></li><li><a href="Number.html#toEnum">toEnum</a></li><li><a href="Number.html#toTime">toTime</a></li><li><a href="Number.html#truncToInt">truncToInt</a></li><li><a href="Number.html#zeroPadd">zeroPadd</a></li></ul></div></li><li><a href="Object.html">Object</a><button type="button" class="hidden toggle-subnav btn btn-link">  <span class="glyphicon glyphicon-plus"></span></button><div class="hidden" id="Object_sub"><div class="member-type">Methods</div><ul class="inner"><li><a href="Object.html#.className">className</a></li><li><a href="Object.html#.contains">contains</a></li><li><a href="Object.html#.copy">copy</a></li><li><a href="Object.html#.isPrimitive">isPrimitive</a></li><li><a href="Object.html#.isType">isType</a></li><li><a href="Object.html#className">className</a></li><li><a href="Object.html#clone">clone</a></li><li><a href="Object.html#contains">contains</a></li><li><a href="Object.html#is">is</a></li><li><a href="Object.html#isPrimitive">isPrimitive</a></li><li><a href="Object.html#merge">merge</a></li></ul></div></li><li><a href="StringList.html">StringList</a><button type="button" class="hidden toggle-subnav btn btn-link">  <span class="glyphicon glyphicon-plus"></span></button><div class="hidden" id="StringList_sub"><div class="member-type">Methods</div><ul class="inner"><li><a href="StringList.html#clear">clear</a></li><li><a href="StringList.html#count">count</a></li><li><a href="StringList.html#empty">empty</a></li><li><a href="StringList.html#forEach">forEach</a></li><li><a href="StringList.html#line">line</a></li><li><a href="StringList.html#load">load</a></li><li><a href="StringList.html#merge">merge</a></li><li><a href="StringList.html#newLine">newLine</a></li><li><a href="StringList.html#remove">remove</a></li><li><a href="StringList.html#save">save</a></li><li><a href="StringList.html#toString">toString</a></li><li><a href="StringList.html#write">write</a></li><li><a href="StringList.html#writeLine">writeLine</a></li></ul></div></li></ul></div>
</nav>
<div id="resizer"></div>

<div class="main" id="main">
    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>"use strict";

/**
 * @file
 *
 * This module contains extensions to common JavaScript objects such as &lt;tt>Object&lt;/tt>,
 * &lt;tt>Number&lt;/tt> and &lt;tt>Date&lt;/tt>. Extensions need to be registered using the
 * &lt;tt>init&lt;/tt> function. This function take a single optional parameter that indicates the
 * object to extend, if the parameter is omitted all extensions are registered.
 *
 * &lt;hr>
 * &lt;h4>Important&lt;/h4>
 * This is typically bad practice as some
 * of these functions may be introduced in future versions of JavaScript, but wrapping
 * them the way libraries like &lt;b>moment&lt;/b> do compromises performance since a wrapper
 * object has to be created with a reference to the underlying object instance, so
 * here we buy the bullet and pray!!
 *
 * For the most part instance members are the ones at most risk, most of the functions
 * defined here are very unlikely to be introduced in future version of JS except perhaps
 * for single word functions such as &lt;tt>clone&lt;/tt>, &lt;tt>copy&lt;/tt> and
 * &lt;tt>contains&lt;/tt>, etc. as well as some of the most commonly named functions like
 * &lt;tt>className&lt;/tt>, &lt;tt>isType&lt;/tt>, &lt;tt>isPrimitive&lt;/tt> etc.
 *
 * @example
 * // Register all extensions
 * require("@crabel/proto").init();
 *
 * // Registers "Object" extensions only
 * require("@crabel/proto").init(Object);
 *
 * //Registers "Date" and "Array" extensions
 * require("@crabel/proto").init(Date, Array);
 * @module @crabel/shared/proto
 * @exports init
 */



// =======================
// == Object Extensions ==
// =======================


/**
 * @alias Object
 * @constructor
 */
function ObjExt() {}

/**
 * Returns true of the object matches the given type. objType should be a function
 * constructor such as &lt;tt>Number&lt;/tt>, &lt;tt>Date&lt;/tt>, &lt;tt>String&lt;/tt>, etc.
 * @param {Object} obj
 * Object instance to test.
 * @param {Function} type
 * Constructor function defining the type to test against.
 * @returns {Boolean}
 */
ObjExt.isType = function (obj, type) {
    if (undefined === obj || null === obj)
        return obj === type;

    if ("number" === typeof obj) return type === Number;
    if ("string" === typeof obj) return type === String;
    if ("boolean" === typeof obj) return type === Boolean;

    return obj instanceof type;
};

/**
 * Returns true if the given value &lt;tt>val&lt;/tt> is one of the primitive types
 * &lt;tt>Number&lt;/tt>, &lt;tt>String&lt;/tt>, &lt;tt>Boolean&lt;/tt>, &lt;tt>null&lt;/tt> or
 * &lt;tt>undefined&lt;/tt>.
 * @param {*} val
 * Variable to inspect.
 * @returns {Boolean}
 */
ObjExt.isPrimitive = function (val) {
    if (undefined === val || null === val)
        return true;

    if ("object" === typeof val)
        return (
            ObjExt.isType(val, Number) ||
            ObjExt.isType(val, String) ||
            ObjExt.isType(val, Boolean)
        );

    return (
        "number" === typeof val ||
        "string" === typeof val ||
        "boolean" === typeof val
    );
};


/** Get name of the constructor function. This is used during registration to determine
 * which object is being registered. This function does not rely on &lt;b>arguments&lt;/b> so
 * it is compatible with ES6 and &lt;tt>strict&lt;/tt> mode.
 * @param {Object} obj
 * Object to inspect.
 * @returns {String}
 * Name of the function used to construct the object.
 */
ObjExt.className = function (obj) {
    let funcNameRegex = /function ([^(]*)/;
    let results = (funcNameRegex).exec((obj).toString());
    return (results &amp;&amp; results.length > 1) ? results[1] : "";
};

/**
 * Creates a copy of the given object. By default the &lt;tt>clone&lt;/tt> function
 * performs a deep copy of the object, passing &lt;tt>deep = false&lt;/tt> will only clone
 * the properties directly owned by the object are transfer to the object includinig
 * &lt;tt>Date&lt;/tt> objects.
 *
 * NOTE: &lt;tt>clone&lt;/tt> is replaceable, &lt;tt>copy&lt;/tt> is not since is a static method.
 * @param {Object} src
 * Reference to the object to be copied.
 * @param {Boolean} [deep=true]
 * Determines if child objects are copied too.
 * @returns {Object}
 * Copy of the object given by &lt;tt>src&lt;/tt>
 */
ObjExt.copy = function (src, deep) {
    if (!src)
        return src;

    // if primitive, just return the value
    if (ObjExt.isPrimitive(src))
        return src.valueOf();

    if (ObjExt.isType(src, Date))
        return new Date(src.getTime());

    if (undefined === deep)
        deep = true;

    let res;
    if (ObjExt.isType(src, Array))
        res = [];
    else
        res = {};

    for (let attr in src) {
        if (src.hasOwnProperty(attr)
            &amp;&amp; null != src[attr] &amp;&amp; "object" == typeof (src[attr])
        ) {
            // Recursion when cloning the Date object fails on return, who knows why...
            // Try it if you don't believe me :)
            if (src[attr] instanceof Date)
                res[attr] = new Date(src[attr].getTime());
            else if (deep)
                res[attr] = ObjExt.copy(src[attr], true);
        }
        else
            res[attr] = src[attr];
    }
    return res;
};

/**
 * Returns true if &lt;tt>src&lt;/tt> fully contains &lt;tt>child&lt;/tt>. The comparison is
 * recursive so all properties and children's properties of 'tgt' must also exist in
 * &lt;tt>src&lt;/tt> and have the same values.
 * @param {*} src
 * @param {*} child
 * @returns {Boolean}
 */
ObjExt.contains = function (src, child) {
    if (ObjExt.isPrimitive(src)) {
        if (ObjExt.isPrimitive(child))
            return (child === src);

        return false;
    }

    if (ObjExt.isPrimitive(child)) {
        for (let k in src)
            if (src.hasOwnProperty(k))
                if (ObjExt.contains(src[k], child))
                    return true;

        return false;
    }

    for (let k in child)
        if (child.hasOwnProperty(k)) {
            if (!src.hasOwnProperty(k))
                return containedByChild();

            // Compare primitive, 'undefined' or 'null' child[k]
            if (src[k] instanceof Date) {
                if (child[k] instanceof Date)
                    return src[k].getTime() === child[k].getTime();
                return false;
            }
            if (ObjExt.isPrimitive(src[k])) {
                if (ObjExt.isPrimitive(child[k])) {
                    if (child[k] === src[k])
                        continue;
                    else
                        return containedByChild();
                }
                return false;
            }

            // If source branch doesn't contain child branch, try other children of source
            if (!ObjExt.contains(src[k], child[k]))
                return containedByChild();
        }

    return true;


    function containedByChild() {
        for (let s in src)
            if (src.hasOwnProperty(s))
                if (ObjExt.contains(src[s], child))
                    return true;
        return false;

    }
};

/**
 * Returns true of the object matches the given type. objType should be a function
 * constructor such as 'Number', 'Date', 'String', etc.
 * @param {Function} objType
 * @returns {Boolean}
 */
ObjExt.prototype.is = function (objType) {
    return ObjExt.isType(this, objType);
};

/**
 * Returns true if this object is one of the primitive types &lt;tt>Number&lt;/tt>,
 * &lt;tt>String&lt;/tt> or &lt;tt>Boolean&lt;/tt>.
 * @returns {Boolean}
 */
ObjExt.prototype.isPrimitive = function () {
    return ObjExt.isPrimitive(this);
};

/**
 * Makes a copy of the current object. All attributes are copied including dates and
 * strings. The returned object has no common references with the original object. If the
 * optional parameter "deep" is set to true, the object is recursively cloned, all
 * aggregated objects and arrays are also cloned.
 * @param deep
 * @returns {Object}
 */
ObjExt.prototype.clone = function (deep) {
    return Object.copy(this, deep);
};

/**
 * Returns true of 'this' fully contains 'tgt'. The comparison is recursive so all
 * properties and children's properties of 'tgt' must also exist in this' and have the
 * same values.
 * @param {Object} tgt
 * @returns {Boolean}
 */
ObjExt.prototype.contains = function (tgt) {
    return ObjExt.contains(this, tgt);
};

/**
 * Merges the attributes from &lt;b>src&lt;/b> into '&lt;b>this&lt;/b> object. If &lt;b>replace&lt;/b> is
 * true, all overlapping attributes are replaced.
 * NOTE: Recursion when cloning the Date object fails on return, who knows why... try it
 * if you don't believe me :)
 * @param {Object} src
 * @param {Boolean} replace
 * @param {Boolean} deep
 * @returns {Object}
 */
ObjExt.prototype.merge = function (src, replace, deep) {
    if (undefined === src || null === src)
        return this;

    if (undefined === deep)
        deep = true;

    for (let attr in src) {
        if (src.hasOwnProperty(attr)) {
            if (!src[attr] || ObjExt.isPrimitive(src[attr])) {
                if (undefined === this[attr] || replace)
                    if (src[attr] instanceof Date)
                        this[attr] = new Date(src[attr].getTime());
                    else
                        this[attr] = src[attr];
            }
            else if (deep) {
                if (undefined === this[attr] ||
                    (replace &amp;&amp; ObjExt.isPrimitive(this[attr]))
                )
                    this[attr] = ObjExt.copy(src[attr], true);
                else
                    this[attr].merge(src[attr], replace, true);
            }
        }
    }

    return this;    // allow method to be called on object assignment
};

/**
 * Returns the name of the constructor function that was used to create the instance.
 * @returns {String}
 */
ObjExt.prototype.className = function () {
    return ObjExt.className((this).constructor);
};



// =======================
// == Number Extensions ==
// =======================


/**
 * @alias Number
 * @constructor
 */
function NumExt() {}


/**
 * Rounds the number &lt;b>this&lt;/b> to the given integer amount.
 * @param {Number} amount
 * @returns {Number}
 */
NumExt.prototype.roundToInt = function (amount) {
    return Math.round(this / amount) * amount;
};

/**
 * Truncates the number &lt;b>this&lt;/b> to the given integer amount.
 * @param {Number} amount
 * @returns {number}
 */
NumExt.prototype.truncToInt = function (amount) {
    return Math.floor(this / amount) * amount;
};

/**
 * Calculates the next closest power of 2 number.
 * @returns {Number}
 */
NumExt.prototype.nextPow2 = function () {
    let x = Math.ceil(this);

    x -= 1;
    x |= (x >> 1);
    x |= (x >> 2);
    x |= (x >> 4);
    x |= (x >> 8);
    x |= (x >> 16);

    return x + 1;
};

/**
 * Calculates the previous closest power of 2 number.
 * @returns {Number}
 */
NumExt.prototype.prevPow2 = function () {
    return Number(Math.floor(this) + 1).nextPow2() >> 1;
};

/**
 * Returns a string pre-appending any necessary 0s to reach the given width
 * @param {Number} width
 * @returns {String}
 */
NumExt.prototype.zeroPadd = function (width) {
    let num_str = this.toString();
    let len = width - num_str.length;
    for (let i = 0; i &lt; len; ++i)
        num_str = "0" + num_str;
    return num_str;
};

/**
 * Assumes the input is in milliseconds (straight from dateExt.getTime)
 * Format Specs:
 * &lt;ul>
 *      &lt;li>h[h]    = hours
 *      &lt;li>m[m]    = minutes
 *      &lt;li>s[s]    = seconds
 *      &lt;li>f       = hundreds of a second
 *      &lt;li>ff      = tens of a seconds
 *      &lt;li>fff     = milliseconds
 * &lt;/ul>
 * Text enclosed within {} brackets is excluded from substitution however the brackets
 * are removed. To preserve the braces use double braces: {{test}} = {test}
 * @param {String} [format]
 * @returns {String}
 */
NumExt.prototype.toTime = function (format) {
    if (undefined === format)
        format = "hh:mm:ss";

    let time = Math.abs(this);
    let seconds = time/ 1000;
    let hours = (this >= 0) ?
        Math.floor(seconds / 3600) : -1 * Math.floor(seconds / 3600);
    let minutes = Math.floor((seconds % 3600) / 60);
    seconds = Math.floor(seconds % 60);
    let millis = Math.floor(time% 1000);
    let tens_of_millis = Math.floor(millis / 10);
    let hundreds_of_millis = Math.floor(tens_of_millis / 10);

    return formatTime();

    function formatTime()
    {
        let bits = [];
        let closeSplit = format.split("}");
        for (let i = 0; i &lt; closeSplit.length; ++i)
        {
            let openSplit = closeSplit[i].split("{");

            openSplit[0] = openSplit[0].replace("hh", hours.zeroPadd(2));
            openSplit[0] = openSplit[0].replace("h", hours);

            openSplit[0] = openSplit[0].replace("mm", minutes.zeroPadd(2));
            openSplit[0] = openSplit[0].replace("m", minutes);

            openSplit[0] = openSplit[0].replace("ss", seconds.zeroPadd(2));
            openSplit[0] = openSplit[0].replace("s", seconds);

            openSplit[0] = openSplit[0].replace("fff", millis.zeroPadd(3));
            openSplit[0] = openSplit[0].replace("ff", tens_of_millis.zeroPadd(2));
            openSplit[0] = openSplit[0].replace("f", hundreds_of_millis.zeroPadd(1));

            if (millis > 0)
                openSplit[0] = openSplit[0].replace("FFF", millis);
            if (tens_of_millis > 0)
                openSplit[0] = openSplit[0].replace("FF", tens_of_millis);
            if (hundreds_of_millis > 0)
                openSplit[0] = openSplit[0].replace("F", hundreds_of_millis);

            bits.push(openSplit.join(""));
        }

        return bits.join("");
    }
};

/**
 * Returns a string with the number as an enumeration (1st, 2nd, 3rd, 4th, etc)
 * @returns {String}
 */
NumExt.prototype.toEnum = function () {
    let val = Math.abs(Number(this));
    if (1 == val) return this + "st";
    if (2 == val) return this + "nd";
    if (3 == val) return this + "rd";
    return this + "th";

};

/**
 * Returns true if the number is within the given range. By default the range is
 * interpreted as a close range, passing 'inclusive = false' will make it an open range.
 * @param {Number} first
 * @param {Number} second
 * @param {Boolean} inclusive
 * @returns {Boolean}
 */
NumExt.prototype.between = function (first, second, inclusive)
{
    if (isNaN(first) || isNaN(second))
        throw new Error("Invalid cal to \"between\", the input parameters must " +
            "be numeric.");

    first = Number(first);
    second = Number(second);

    let low = Math.min(first, second);
    let high = Math.max(first, second);

    if (undefined === inclusive || inclusive)
        return (this >= low &amp;&amp; this &lt;= high);

    return (this > low &amp;&amp; this &lt; high);
};



// ===================
// ==Date Extensions==
// ===================

/**
 * @alias Date
 * @constructor
 */
function DateExt() {}


/**
 * Formats the given date "dt" using the formatting specifications in fstr. The following
 * formatting tokens apply:
 *  &lt;table style="width: 100%">
 *      &lt;tr>&lt;/td>&lt;td>&lt;b>yyyy&lt;/b>&lt;/td>&lt;td style="width: 6px">&lt;/td>&lt;td>Four digit year&lt;/td>&lt;/tr>
 *      &lt;tr>&lt;td>&lt;b>yy&lt;/b>&lt;/td>&lt;td>&lt;/td>&lt;td>Two digit year&lt;/td>&lt;/tr>
 *      &lt;tr>&lt;td>&lt;b>MM&lt;/b>&lt;/td>&lt;td>&lt;/td>&lt;td>Two digit month&lt;/td>&lt;/tr>
 *      &lt;tr>&lt;td>&lt;b>M&lt;/b>&lt;/td>&lt;td>&lt;/td>&lt;td>Single digit month (when less than 10)&lt;/td>&lt;/tr>
 *      &lt;tr>&lt;td>&lt;b>MMMM&lt;/b>&lt;/td>&lt;td>&lt;/td>&lt;td>Month of the year, full name&lt;/td>&lt;/tr>
 *      &lt;tr>&lt;td>&lt;b>MMM&lt;/b>&lt;/td>&lt;td>&lt;/td>&lt;td>Month of the year, short name&lt;/td>&lt;/tr>
 *      &lt;tr>&lt;td>&lt;b>dd&lt;/b>&lt;/td>&lt;td>&lt;/td>&lt;td>Two digit day&lt;/td>&lt;/tr>
 *      &lt;tr>&lt;td>&lt;b>d&lt;/b>&lt;/td>&lt;td>&lt;/td>&lt;td>Single digit day (when less than 10)&lt;/td>&lt;/tr>
 *      &lt;tr>&lt;td>&lt;b>dddd&lt;/b>&lt;/td>&lt;td>&lt;/td>&lt;td>Day of the week, full name&lt;/td>&lt;/tr>
 *      &lt;tr>&lt;td>&lt;b>ddd&lt;/b>&lt;/td>&lt;td>&lt;/td>&lt;td>Day of the week, short name&lt;/td>&lt;/tr>
 *      &lt;tr>&lt;td>&lt;b>HH&lt;/b>&lt;/td>&lt;td>&lt;/td>&lt;td>Two digit hour, 24 hour clock&lt;/td>&lt;/tr>
 *      &lt;tr>&lt;td>&lt;b>H&lt;/b>&lt;/td>&lt;td>&lt;/td>&lt;td>Single digit hour (when less than 10), 24 hour clock&lt;/td>&lt;/tr>
 *      &lt;tr>&lt;td>&lt;b>hh&lt;/b>&lt;/td>&lt;td>&lt;/td>&lt;td>Two digit hour, 12 hour clock&lt;/td>&lt;/tr>
 *      &lt;tr>&lt;td>&lt;b>h&lt;/b>&lt;/td>&lt;td>&lt;/td>&lt;td>Single digit hour (when less than 10), 12 hour clock&lt;/td>&lt;/tr>
 *      &lt;tr>&lt;td>&lt;b>TT&lt;/b>&lt;/td>&lt;td>&lt;/td>&lt;td>Time of day (AM/PM)&lt;/td>&lt;/tr>
 *      &lt;tr>&lt;td>&lt;b>T&lt;/b>&lt;/td>&lt;td>&lt;/td>&lt;td>Time of day (A/P)&lt;/td>&lt;/tr>
 *      &lt;tr>&lt;td>&lt;b>tt&lt;/b>&lt;/td>&lt;td>&lt;/td>&lt;td>Time of day in lowercase (am/pm)&lt;/td>&lt;/tr>
 *      &lt;tr>&lt;td>&lt;b>t&lt;/b>&lt;/td>&lt;td>&lt;/td>&lt;td>Time of day in lowercase (a/b)&lt;/td>&lt;/tr>
 *      &lt;tr>&lt;td>&lt;b>mm&lt;/b>&lt;/td>&lt;td>&lt;/td>&lt;td>Two digit minute&lt;/td>&lt;/tr>
 *      &lt;tr>&lt;td>&lt;b>m&lt;/b>&lt;/td>&lt;td>&lt;/td>&lt;td>Single digit minute (when less than 10)&lt;/td>&lt;/tr>
 *      &lt;tr>&lt;td>&lt;b>ss&lt;/b>&lt;/td>&lt;td>&lt;/td>&lt;td>Two digit second&lt;/td>&lt;/tr>
 *      &lt;tr>&lt;td>&lt;b>s&lt;/b>&lt;/td>&lt;td>&lt;/td>&lt;td>Single digit second (when less than 10)&lt;/td>&lt;/tr>
 *      &lt;tr>&lt;td>&lt;b>fff&lt;/b>&lt;/td>&lt;td>&lt;/td>&lt;td>Milliseconds, zero padded 3 digit number&lt;/td>&lt;/tr>
 *      &lt;tr>&lt;td>&lt;b>ff&lt;/b>&lt;/td>&lt;td>&lt;/td>&lt;td>Tens of milliseconds, zero padded 2 digit number&lt;/td>&lt;/tr>
 *      &lt;tr>&lt;td>&lt;b>f&lt;/b>&lt;/td>&lt;td>&lt;/td>&lt;td>Hundreds of milliseconds&lt;/td>&lt;/tr>
 *      &lt;tr>&lt;td>&lt;b>FFF&lt;/b>&lt;/td>&lt;td>&lt;/td>&lt;td>Milliseconds with no padding&lt;/td>&lt;/tr>
 *      &lt;tr>&lt;td>&lt;b>FF&lt;/b>&lt;/td>&lt;td>&lt;/td>&lt;td>Tens of milliseconds, with no padding&lt;/td>&lt;/tr>
 *      &lt;tr>&lt;td>&lt;b>F&lt;/b>&lt;/td>&lt;td>&lt;/td>&lt;td>Hundreds of milliseconds, with no padding&lt;/td>&lt;/tr>
 *      &lt;tr>&lt;td>&lt;b>KKK&lt;/b>&lt;/td>&lt;td>&lt;/td>&lt;td>Timezone long description > GMT-0700 (PDT)&lt;/td>&lt;/tr>
 *      &lt;tr>&lt;td>&lt;b>KK&lt;/b>&lt;/td>&lt;td>&lt;/td>&lt;td>Timezone short description > PDT&lt;/td>&lt;/tr>
 *      &lt;tr>&lt;td>&lt;b>K&lt;/b>&lt;/td>&lt;td>&lt;/td>&lt;td>Timezone offset from GMT > -0700&lt;/td>&lt;/tr>
 *  &lt;/table>
 *
 * Use the "{" and "}" brackets to enclose text where date substitution should be avoided.
 * @param {Date} dt Instance of &lt;tt>date&lt;/tt> to format.
 * @param {String} fstr Format string, e.g. "yyyy/MM/dd"
 * @param {Function} [replacer] Optional function to replace the date/time tokens. If
 * omitted, the default substitution is used.
 * @returns {String}
 */
DateExt.format = function (dt, fstr, replacer)
{
    if (!replacer || !ObjExt.isType(replacer, Function))
        replacer = function () { return null; };

    if (undefined === fstr)
        fstr = "MM/dd/yyyy hh:mm:ss";

    // First resolve all name related tokens and enclose within {} to avoid the
    // token substitution from affecting the month and day of week names.

    fstr = protectEscapedChars(fstr);
    fstr = resolveNames(dt, fstr);

    let h12 = (dt.getHours() > 12) ? dt.getHours() - 12 : dt.getHours();
    let millis = dt.getMilliseconds();
    let tens_of_millis = Math.round(millis / 10);
    let hundreds_of_millis = Math.round(tens_of_millis / 10);

    let bits = [];
    let closeSplit = fstr.split("}");
    for (let i = 0; i &lt; closeSplit.length; ++i)
    {
        let openSplit = closeSplit[i].split("{");

        // Long tokens first to avoid partial match substitution
        openSplit[0] = openSplit[0].replace("yyyy", replacer(dt, "yyyy") ||
            dt.getFullYear());
        openSplit[0] = openSplit[0].replace("yy", replacer(dt, "yy") ||
            dt.getYear());

        openSplit[0] = openSplit[0].replace("MM", replacer(dt, "MM") ||
            (dt.getMonth() + 1).zeroPadd(2));
        openSplit[0] = openSplit[0].replace("M", replacer(dt, "M") ||
            (dt.getMonth() + 1));

        openSplit[0] = openSplit[0].replace("dd", replacer(dt, "dd") ||
            dt.getDate().zeroPadd(2));
        openSplit[0] = openSplit[0].replace("d", replacer(dt, "d") ||
            dt.getDate());

        openSplit[0] = openSplit[0].replace("HH", replacer(dt, "HH") ||
            dt.getHours().zeroPadd(2));
        openSplit[0] = openSplit[0].replace("H", replacer(dt, "H") ||
            dt.getHours());
        openSplit[0] = openSplit[0].replace("hh", replacer(dt, "hh") ||
            h12.zeroPadd(2));
        openSplit[0] = openSplit[0].replace("h", replacer(dt, "h") ||
            h12);

        openSplit[0] = openSplit[0].replace("mm", replacer(dt, "mm") ||
            dt.getMinutes().zeroPadd(2));
        openSplit[0] = openSplit[0].replace("m", replacer(dt, "m") ||
            dt.getMinutes());

        openSplit[0] = openSplit[0].replace("ss", replacer(dt, "ss") ||
            dt.getSeconds().zeroPadd(2));
        openSplit[0] = openSplit[0].replace("s", replacer(dt, "s") ||
            dt.getSeconds());

        openSplit[0] = openSplit[0].replace("fff", replacer(dt, "fff") ||
            millis.zeroPadd(3));
        openSplit[0] = openSplit[0].replace("ff", replacer(dt, "ff") ||
            tens_of_millis.zeroPadd(2));
        openSplit[0] = openSplit[0].replace("f", replacer(dt, "f") ||
            hundreds_of_millis.zeroPadd(1));

        openSplit[0] = openSplit[0].replace("FFF", replacer(dt, "FFF") ||
            millis);
        openSplit[0] = openSplit[0].replace("FF", replacer(dt, "FF") ||
            tens_of_millis);
        openSplit[0] = openSplit[0].replace("F", replacer(dt, "F") ||
            hundreds_of_millis);

        bits.push(openSplit.join(""));
    }

    return replaceTokens(bits.join(""));

    function protectEscapedChars(str)
    {
        str = str.replace(/{{/g, "{:OBRACKET:}");
        str = str.replace(/}}/g, "{:CBRACKET:}");
        return str;
    }

    function replaceTokens(str)
    {
        str = str.replace(/:OBRACKET:/g, "{", "g");
        str = str.replace(/:CBRACKET:/g, "}", "g");
        return str;
    }

    function resolveNames(dt, fstr)
    {
        let dow = [
            "Sunday",       "Monday",       "Thuesday",     "Wednesday",
            "Thursday",     "Friday",       "Saturday"];
        let dow_short = [
            "Sun", "Mon", "Tue", "Wed",
            "Thu", "Fri", "Sat"];
        let month = [
            "January",      "Februaty",     "March",        "April",        "May",
            "June",         "July",         "August",       "September",    "October",
            "November",     "December"];
        let month_short = [
            "Jan", "Feb", "Mar", "Apr", "May", "Jun",
            "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];

        let bits = [];
        let closeSplit = fstr.split("}");
        let pm = (dt.getHours() >= 12);
        for (let i = 0; i &lt; closeSplit.length; ++i)
        {
            let openSplit = closeSplit[i].split("{");

            openSplit[0] = openSplit[0].replace("TT", "{" + (replacer(dt, "tt") ||
                (pm ? "PM" : "AM")) + "}");
            openSplit[0] = openSplit[0].replace("T", "{" + (replacer(dt, "t") ||
                (pm ? "P" : "A")) + "}");
            openSplit[0] = openSplit[0].replace("tt", "{" + (replacer(dt, "tt") ||
                (pm ? "pm" : "am")) + "}");
            openSplit[0] = openSplit[0].replace("t", "{" + (replacer(dt, "t") ||
                (pm ? "p" : "a")) + "}");

            openSplit[0] = openSplit[0].replace("MMMM", "{" + (replacer(dt, "MMMM") ||
                month[dt.getMonth()]) + "}");
            openSplit[0] = openSplit[0].replace("MMM", "{" + (replacer(dt, "MM") ||
                month_short[dt.getMonth()]) + "}");

            openSplit[0] = openSplit[0].replace("dddd", "{" + (replacer(dt, "dddd") ||
                dow[dt.getDay()]) + "}");
            openSplit[0] = openSplit[0].replace("ddd", "{" + (replacer(dt, "ddd") ||
                dow_short[dt.getDay()]) + "}");

            // TODO : Timezone replacement has not yet been implemented.
            openSplit[0] = openSplit[0].replace("KKK", "{" + (replacer(dt, "KKK") ||
                "KKK") + "}");
            openSplit[0] = openSplit[0].replace("KK", "{" + (replacer(dt, "KK") ||
                "KK") + "}");
            openSplit[0] = openSplit[0].replace("K", "{" + (replacer(dt, "K") ||
                "K") + "}");

            bits.push(openSplit.join("{"));
        }

        return bits.join("}");
    }
};

/**
 * Compares the two dates and returns true if they point to the same day.
 * @param {Date} date1 First date to compare.
 * @param {Date} date2 Second date to compare.
 * @returns {Boolean}
 */
DateExt.sameDay = function (date1, date2)
{
    return date1.getFullYear() == date2.getFullYear()
        &amp;&amp; date1.getMonth() == date2.getMonth()
        &amp;&amp; date1.getDate() == date2.getDate();
};

/**
 * Returns the maximum length that the given format string can yield after a date is
 * formatted.
 * Usage:
 * &lt;ul>
 *      &lt;li>&lt;tt>let len = DateExt.formatLength("yyyy/mm/dd");  // len = 10&lt;/tt>
 *      &lt;li>&lt;tt>let len = DateExt.formatLength("yyy/m/d");     // len = 10&lt;/tt>
 * &lt;/ul>
 * @param {String} format_str
 * @param {Function} [replacer] Function to replace date/time tokens.
 * @returns {Number}
 */
DateExt.formatLength = function (format_str, replacer)
{
    // using a date that has 2 digit month, day, hour, minute and second,
    // and 3 digits for milliseconds that won't round to zero when doing
    // tens or hundreds of millis.
    let full_date = new Date(2015, 10, 17, 12, 45, 45, 123);
    return full_date.format(format_str, replacer).length;
};


// == Instance Members ==

/**
 * Returns copy of &lt;tt>this&lt;/tt> and adds &lt;tt>y&lt;/tt> number of years to it. The number of
 * years to add can be negative.
 * @param {Number} [y=1] Number of years to add.
 * @returns {Date} Returns a new instance of &lt;tt>Date&lt;/tt>.
 */
DateExt.prototype.addYears = function (y)
{
    if (isNaN(y)) y = 1;
    return new Date(
        this.getFullYear() + y, this.getMonth(), this.getDate(),
        this.getHours(), this.getMinutes(), this.getSeconds(), this.getMilliseconds()
    );
};

/**
 * Adds &lt;tt>y&lt;/tt> number of years to &lt;tt>this&lt;/tt> and returns it to allow chaining.
 * @param {Number} [y=1] Number of years to add.
 * @returns {Date} Returns &lt;tt>this&lt;/tt> after incrementing it's value.
 */
DateExt.prototype.incYear = function (y)
{
    if (isNaN(y)) y = 1;
    this.setFullYear(this.getFullYear() + y);
    return this;
};

/**
 * Returns copy of &lt;tt>this&lt;/tt> and adds &lt;tt>m&lt;/tt> number of months to it. The number of
 * months can be negative.
 * @param {Number} [m=1] Number of months to add.
 * @returns {Date} Returns a new instance of &lt;tt>Date&lt;/tt>.
 */
DateExt.prototype.addMonths = function (m)
{
    if (isNaN(m)) m = 1;
    let res = new Date(this.getTime());
    res.setMonth(res.getMonth() + m);
    return res;
};

/**
 * Adds &lt;b>m&lt;/b> number of months to &lt;b>this&lt;/b> and returns it to allow chaining.
 * @param {Number} [m=1] Number of months to add.
 * @returns {Date} Returns &lt;tt>this&lt;/tt> after incrementing it's value.
 */
DateExt.prototype.incMonth = function (m)
{
    if (isNaN(m)) m = 1;
    this.setMonth(this.getMonth() + m);
};

/**
 * Returns copy of &lt;b>this&lt;/b> and adds &lt;b>d&lt;/b> number of days to it. The number of days
 * can be negative.
 * @param {Number} [d=1] Number of days to add.
 * @returns {Date} Returns a new instance of &lt;tt>Date&lt;/tt>.
 */
DateExt.prototype.addDays = function (d)
{
    if (isNaN(d)) d = 1;
    return new Date(this.getTime() + (d * 36e5 * 24));
};

/**
 * Adds &lt;tt>d&lt;/tt> number of days to &lt;tt>this&lt;/tt> and returns it to allow chaining.
 * @param {Number} [d=1] Number of days to add.
 * @returns {Date} Returns &lt;tt>this&lt;/tt> after incrementing it's value.
 */
DateExt.prototype.incDay = function (d)
{
    if (isNaN(d)) d = 1;
    this.setTime(this.getTime() + (d * 36e5 * 24));
};

/**
 * Returns copy of &lt;tt>this&lt;/tt> and adds &lt;tt>h&lt;/tt> number of hours to it.
 * @param {Number} [h=1] Number of hours to add.
 * @returns {Date} Returns a new instance of &lt;tt>Date&lt;/tt>.
 */
DateExt.prototype.addHours = function (h)
{
    if (isNaN(h)) h = 1;
    return new Date(this.getTime() + (h * 36e5));
};

/**
 * Adds &lt;tt>h&lt;/tt> number of hours to &lt;tt>this&lt;/tt> and returns it to allow chaining.
 * @param {Number} [h=1] Number of hours to add.
 * @returns {Date} Returns &lt;tt>this&lt;/tt> after incrementing it's value.
 */
DateExt.prototype.incHour = function (h)
{
    if (isNaN(h)) h = 1;
    this.setTime(this.getTime() + (h * 36e5));
};

/**
 * Returns copy of &lt;tt>this&lt;/tt> and adds &lt;tt>m&lt;/tt> number of minutes to it. The number
 * of minutes can be negative.
 * @param {Number} [m=1] Number of minutes to add.
 * @returns {Date} Returns a new instance of &lt;tt>Date&lt;/tt>.
 */
DateExt.prototype.addMinutes = function (m)
{
    if (isNaN(m)) m = 1;
    return new Date(this.getTime() + (m * 6e4));
};

/**
 * Adds &lt;tt>h&lt;/tt> number of minutes to &lt;tt>this&lt;/tt> and returns it to allow chaining.
 * @param {Number} [m=1] Number of minutes to add.
 * @returns {Date} Returns &lt;tt>this&lt;/tt> after incrementing it's value.
 */
DateExt.prototype.incMinute = function (m)
{
    if (isNaN(m)) m = 1;
    this.setTime(this.getTime() + (m * 6e4));
};

/**
 * Returns copy of &lt;tt>this&lt;/tt> and adds &lt;tt>d&lt;/tt> number of seconds to it. The number of
 * seconds can be negative.
 * @param {Number} [s=1] Number of seconds to add.
 * @returns {Date} Returns a new instance of &lt;tt>Date&lt;/tt>.
 */
DateExt.prototype.addSeconds = function (s)
{
    if (isNaN(s)) s = 1;
    return new Date(this.getTime() + (s * 1000));
};

/**
 * Adds &lt;tt>h&lt;/tt> number of seconds to &lt;tt>this&lt;/tt> and returns it to allow chaining.
 * @param {Number} [s=1] Number of seconds to add.
 * @returns {Date} Returns &lt;tt>this&lt;/tt> after incrementing it's value.
 */
DateExt.prototype.incSecond = function (s)
{
    if (isNaN(s)) s = 1;
    return this.setTime(this.getTime() + (s * 1000));
};

/**
 * Returns copy of &lt;tt>this&lt;/tt> and adds &lt;tt>d&lt;/tt> number of milliseconds to it. The number
 * of milliseconds can be negative.
 * @param {Number} [ms=1] Number of milliseconds to add.
 * @returns {Date} Returns a new instance of &lt;tt>Date&lt;/tt>.
 */
DateExt.prototype.addMillis = function (ms)
{
    if (isNaN(ms)) ms = 1;
    return new Date(this.getTime() + ms);
};

/**
 * Adds &lt;tt>h&lt;/tt> number of milliseconds to &lt;tt>this&lt;/tt> and returns it to allow
 * chaining.
 * @param {Number} [ms=1] Number of milliseconds to add.
 * @returns {Date} Returns &lt;tt>this&lt;/tt> after incrementing it's value.
 */
DateExt.prototype.incMilli = function (ms)
{
    if (isNaN(ms)) ms = 1;
    return this.setTime(this.getTime() + ms);
};

/**
 * Returns the difference between &lt;tt>this&lt;/tt> and &lt;tt>date&lt;/tt> in the given units
 * (milliseconds by default). Supported units are: "day/d", "hour/h", "minute/m",
 * "second/s", "millisecond/msec/f"
 * @param {Date} date The date to compare against
 * @param {String} units Units to compare (day, hour, minute, second, msec).
 * @returns {Number} Returns the difference between the two dates.
 * @throws Throws an error if &lt;tt>units&lt;/tt> are not supported.
 */
DateExt.prototype.diff = function (date, units)
{
    if (!ObjExt.isType(date, Date))
        throw new Error("Invalid call to 'Date.diff', the input is not " +
            "a data.");
    if (!units)
        units = "f";

    if (units === "f" || units === "millisecond" || units === "msec")
        return Math.floor(Math.abs(date.getTime() - this.getTime()));

    if (units === "s" || units === "second")
        return Math.floor(Math.abs(date.getTime() - this.getTime()) / 1000);

    if (units === "m" || units === "minute")
        return Math.floor(Math.abs(date.getTime() - this.getTime()) / 6e4);

    if (units === "h" || units === "hour")
        return Math.floor(Math.abs(date.getTime() - this.getTime()) / 36e6);

    if (units === "d" || units === "day")
        return Math.floor(Math.abs(date.getTime() - this.getTime()) / (36e6 * 24));

    throw new Error("The '" + units + "' units are not supported.");
};

/**
 * Returns a new date object representing the same date/time but in UTC. This is a nasty
 * hack since the returned date still shows the local timezone (no way to change this as
 * far as I know), however it is very convenient to be able to operate on a Date that's
 * already adjusted.
 * @returns {Date}
 */
DateExt.prototype.toUtc = function ()
{
    return new Date(this.getTime() + this.getTimezoneOffset() * 60000);
};


/**
 // Formats the date with the given specification. See &lt;tt>Date.format&lt;/tt> for more
 detail.
 * @param {String} fstr Format string in the form &lt;code>yyyy/MM/dd&lt;/code>
 * @param {Function} [replacer] Optional function to replace the date/time tokens.
 * @returns {string} Returns a string with the formatted date/time
 */
DateExt.prototype.format = function (fstr, replacer)
{
    return DateExt.format(this, fstr, replacer);
};

/**
 * Returns true if &lt;tt>this&lt;/tt> and &lt;tt>date&lt;/tt> point to the same day.
 * @param {Date} date
 * @returns {Boolean}
 */
DateExt.prototype.sameDay = function (date)
{
    return DateExt.sameDay(this, date);
};

/**
 * Returns true if &lt;tt>this&lt;/tt> day is earlier than &lt;tt>date&lt;/tt> ignoring the time.
 * @param {Date} date
 * @returns {Boolean}
 */
DateExt.prototype.earlierDayThan = function (date)
{
    if (this.getFullYear() &lt; date.getFullYear())
        return true;
    else if (this.getFullYear() > date.getFullYear())
        return false;

    if (this.getMonth() &lt; date.getMonth())
        return true;
    else if (this.getMonth() > date.getMonth())
        return false;

    return (this.getDate() &lt; date.getDate());
};

/**
 * Returns true if &lt;b>this&lt;/b> day is later than &lt;b>date&lt;/b> ignoring the time.
 * @param {Date} date
 * @returns {Boolean}
 */
DateExt.prototype.laterDayThan = function (date)
{
    return date.earlierDayThan(this);
};

/**
 * Zeros out the time component of &lt;tt>this&lt;/tt>.
 * @returns {DateExt} Returns &lt;tt>this&lt;/tt> after truncating time.
 */
DateExt.prototype.truncTime = function () {
    this.setHours(0, 0, 0, 0);
    return this;
};



// ======================
// == Array Extensions ==
// ======================

/**
 * @alias Array
 * @constructor
 */
function ArrayExt() {}

// == Instance Members ==

/**
 * Returns the first element in the array. The optional offset parameter can be used to
 * iterate through the array from first to last.
 * @param {Number} [offset=0]
 * Optionally returns the element &lt;tt>offset&lt;/tt> from the first.
 * @returns {*}
 */
ArrayExt.prototype.first = function (offset)
{
    if (!offset)
        offset = 0;

    if (this.length &lt;= offset)
        return null;

    return this[offset];
};

/**
 * Returns the last element in the array. The optional offset parameter can be used to
 * iterate through the array from last to first.
 * @param {Number} [offset=0]
 * Optionally returns the element &lt;tt>offset&lt;/tt> from the last.
 * @returns {*}
 */
ArrayExt.prototype.last = function (offset)
{
    if (!offset)
        offset = 0;

    if (this.length &lt;= offset)
        return null;

    return this[this.length - 1 - offset];
};

/**
 * Returns &lt;tt>true&lt;/tt> if the given index points to the last element in the
 * &lt;tt>Array&lt;/tt>.
 * @param {Number} index
 * @returns {Boolean}
 */
ArrayExt.prototype.isLast = function (index) {
    return ((index + 1) === this.length);
};

/**
 * Returns &lt;tt>true&lt;/tt> if the array has no elements.
 * @returns {Boolean}
 */
ArrayExt.prototype.empty = function ()
{
    return this.length == 0;
};





// ===============

function registerExtension(orig, ext) {
    for (let k in ext)
        if (ext.hasOwnProperty(k)) {
            if (orig.hasOwnProperty(k))
                continue;

            Object.defineProperty(orig, k, {value: ext[k], writable: true});
        }

    if (ext.prototype &amp;&amp; orig.prototype)
        registerExtension(orig.prototype, ext.prototype)
}

module.exports = {
    /**
     * Register the extensions for the given object type, or all extensions if no
     * specific type is provided. Currently only &lt;tt>Object&lt;/tt>, &lt;tt>Number&lt;/tt>,
     * &lt;tt>Date&lt;/tt> and &lt;tt>Array&lt;/tt> are supported.
     * @param {Function} [targets...]
     * The constructor function of the object to extend.
     */
    init: function (targets) {
        let args = Array.prototype.slice.call(arguments);

        if (hasType(Object))    registerExtension(Object, ObjExt);
        if (hasType(Number))    registerExtension(Number, NumExt);
        if (hasType(Date))      registerExtension(Date, DateExt);
        if (hasType(Array))     registerExtension(Array, ArrayExt);


        function hasType(type) {
            "use strict";
            if (0 === args.length)
                return true;

            for (let i = 0; i &lt; args.length; i++)
                if (args[i] === type)
                    return true;

            return false;
        }
    }
};

</code></pre>
        </article>
    </section>




</div>

<footer>
    <img class="logo" src="img/toast-ui.png" style="width: 0px; height: 0px">
    <div class="footer-text">Crabel Shared Library for JavaScript</div>
</footer>
<script>prettyPrint();</script>
<script src="scripts/jquery.min.js"></script>
<script src="scripts/tui-doc.js"></script>
<script src="scripts/linenumber.js"></script>

    <script>
        var id = '_sub'.replace(/"/g, '_');
        var selectedApi = document.getElementById(id); // do not use jquery selector
        var $selectedApi = $(selectedApi);

        $selectedApi.removeClass('hidden');
        $selectedApi.parent().find('.glyphicon').removeClass('glyphicon-plus').addClass('glyphicon-minus');
        showLnbApi();
    </script>

</body>
</html>
