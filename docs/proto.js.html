<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>proto.js - Documentation</title>

    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="https://code.ionicframework.com/ionicons/2.0.1/css/ionicons.min.css">
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
    <link type="text/css" rel="stylesheet" href="styles/custom.css">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav id="nav">
    <h3 class="group-title"><a href="index.html">&#x3C; Home &#x3E;</a></h3><input class="search" placeholder="Search" type="text"><div class="list"><h3 class="group-title">Classes</h3><ul><li><a href="Array.html" class="className">Array</a><ul class='methods'><li data-type='method'><a href="Array.html#empty" class="methodName">empty</a></li><li data-type='method'><a href="Array.html#first" class="methodName">first</a></li><li data-type='method'><a href="Array.html#isLast" class="methodName">isLast</a></li><li data-type='method'><a href="Array.html#last" class="methodName">last</a></li></ul></li><li><a href="Date.html" class="className">Date</a><ul class='methods'><li data-type='method'><a href="Date.html#.format" class="methodName">format</a></li><li data-type='method'><a href="Date.html#.formatLength" class="methodName">formatLength</a></li><li data-type='method'><a href="Date.html#.sameDay" class="methodName">sameDay</a></li><li data-type='method'><a href="Date.html#addDays" class="methodName">addDays</a></li><li data-type='method'><a href="Date.html#addMillis" class="methodName">addMillis</a></li><li data-type='method'><a href="Date.html#addMinutes" class="methodName">addMinutes</a></li><li data-type='method'><a href="Date.html#addMonths" class="methodName">addMonths</a></li><li data-type='method'><a href="Date.html#addSeconds" class="methodName">addSeconds</a></li><li data-type='method'><a href="Date.html#addYears" class="methodName">addYears</a></li><li data-type='method'><a href="Date.html#diff" class="methodName">diff</a></li><li data-type='method'><a href="Date.html#earlierDayThan" class="methodName">earlierDayThan</a></li><li data-type='method'><a href="Date.html#format" class="methodName">format</a></li><li data-type='method'><a href="Date.html#incHour" class="methodName">incHour</a></li><li data-type='method'><a href="Date.html#incMilli" class="methodName">incMilli</a></li><li data-type='method'><a href="Date.html#incMinute" class="methodName">incMinute</a></li><li data-type='method'><a href="Date.html#incMonth" class="methodName">incMonth</a></li><li data-type='method'><a href="Date.html#incSecond" class="methodName">incSecond</a></li><li data-type='method'><a href="Date.html#incYear" class="methodName">incYear</a></li><li data-type='method'><a href="Date.html#laterDayThan" class="methodName">laterDayThan</a></li><li data-type='method'><a href="Date.html#sameDay" class="methodName">sameDay</a></li><li data-type='method'><a href="Date.html#toUtc" class="methodName">toUtc</a></li><li data-type='method'><a href="Date.html#truncTime" class="methodName">truncTime</a></li></ul></li><li><a href="Number.html" class="className">Number</a><ul class='methods'><li data-type='method'><a href="Number.html#between" class="methodName">between</a></li><li data-type='method'><a href="Number.html#nextPow2" class="methodName">nextPow2</a></li><li data-type='method'><a href="Number.html#prevPow2" class="methodName">prevPow2</a></li><li data-type='method'><a href="Number.html#roundToInt" class="methodName">roundToInt</a></li><li data-type='method'><a href="Number.html#toEnum" class="methodName">toEnum</a></li><li data-type='method'><a href="Number.html#toTime" class="methodName">toTime</a></li><li data-type='method'><a href="Number.html#truncToInt" class="methodName">truncToInt</a></li><li data-type='method'><a href="Number.html#zeroPadd" class="methodName">zeroPadd</a></li></ul></li><li><a href="Object.html" class="className">Object</a><ul class='methods'><li data-type='method'><a href="Object.html#.className" class="methodName">className</a></li><li data-type='method'><a href="Object.html#.contains" class="methodName">contains</a></li><li data-type='method'><a href="Object.html#.copy" class="methodName">copy</a></li><li data-type='method'><a href="Object.html#.isPrimitive" class="methodName">isPrimitive</a></li><li data-type='method'><a href="Object.html#.isType" class="methodName">isType</a></li><li data-type='method'><a href="Object.html#className" class="methodName">className</a></li><li data-type='method'><a href="Object.html#clone" class="methodName">clone</a></li><li data-type='method'><a href="Object.html#contains" class="methodName">contains</a></li><li data-type='method'><a href="Object.html#is" class="methodName">is</a></li><li data-type='method'><a href="Object.html#isPrimitive" class="methodName">isPrimitive</a></li><li data-type='method'><a href="Object.html#merge" class="methodName">merge</a></li></ul></li></ul><h3 class="group-title">Modules</h3><ul><li><a href="module-@crabel_proto.html" class="className">@crabel/proto</a><ul class='methods'><li data-type='method'><a href="module-@crabel_proto.html#.init" class="methodName">init</a></li></ul></li></ul></div>
</nav>

<div id="main">
    
        <h1 class="page-title">proto.js</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 * @file
 * This module contains extensions to common JavaScript objects in the form of
 * &lt;b>static&lt;/b> and &lt;b>prototype&lt;/b> functions. Extensions need to be registered using
 * the &lt;tt>init&lt;/tt> function. This function take a single optional parameter that
 * indicates the object to extend, if the parameter is omitted all extensions are
 * registered, for instance:
 *
 * &lt;ul>
 *     &lt;li>Registers all extensions.&lt;br>
 *         &lt;tt>require("@crabel/proto").init()&lt;/tt>
 *     &lt;li>Registers &lt;tt>Object&lt;/tt>extensions only.&lt;br>
 *         &lt;tt>require("@crabel/proto").init(Object)&lt;/tt>
 *     &lt;li>Registers &lt;tt>Date&lt;/tt> and &lt;tt>Array&lt;/tt> extensions.&lt;br>
 *         &lt;tt>require("@crabel/proto").init(Date, Array)&lt;/tt>
 * &lt;/ul>
 *
 * &lt;hr>
 * &lt;h4>Important&lt;/h4>
 * This is typically bad practice as some
 * of these functions may be introduced in future versions of JavaScript, but wrapping
 * them the way libraries like &lt;b>moment&lt;/b> do compromises performance since a wrapper
 * object has to be created with a reference to the underlying object instance, so
 * here we buy the bullet and pray!!
 *
 * For the most part instance members are the ones at most risk, most of the functions
 * defined here are very unlikely to be introduced in future version of JS except perhaps
 * for single word functions such as &lt;tt>clone&lt;/tt>, &lt;tt>copy&lt;/tt> and
 * &lt;tt>contains&lt;/tt>, etc. as well as some of the most commonly named functions like
 * &lt;tt>className&lt;/tt>, &lt;tt>isType&lt;/tt>, &lt;tt>isPrimitive&lt;/tt> etc.
 */

/**
 * @module @crabel/proto
 * @exports init
 */


// =======================
// == Object Extensions ==
// =======================


/**
 * @alias Object
 * @constructor
 */
function ObjExt() {}

/**
 * Returns true of the object matches the given type. objType should be a function
 * constructor such as &lt;tt>Number&lt;/tt>, &lt;tt>Date&lt;/tt>, &lt;tt>String&lt;/tt>, etc.
 * @param {Object} obj
 * Object instance to test.
 * @param {Function} type
 * Constructor function defining the type to test against.
 * @returns {Boolean}
 */
ObjExt.isType = function (obj, type) {
    if (undefined === obj || null === obj)
        return obj === type;

    if ("number" === typeof obj) return type === Number;
    if ("string" === typeof obj) return type === String;
    if ("boolean" === typeof obj) return type === Boolean;

    return obj instanceof type;
};

/**
 * Returns true if the given value 'val' is one of the primitive types
 * &lt;tt>Number&lt;/tt>, &lt;tt>String&lt;/tt> or &lt;tt>Boolean&lt;/tt>.
 * @param {*} val
 * Variable to inspect.
 * @returns {Boolean}
 */
ObjExt.isPrimitive = function (val) {
    if (undefined === val || null === val)
        return false;

    if ("object" === typeof val)
        return (
            ObjExt.isType(val, Number) ||
            ObjExt.isType(val, String) ||
            ObjExt.isType(val, Boolean)
        );

    return (
        "number" === typeof val ||
        "string" === typeof val ||
        "boolean" === typeof val
    );
};


/** Get name of the constructor function. This is used during registration to determine
 * which object is being registered. This function does not rely on &lt;b>arguments&lt;/b> so
 * it is compatible with ES6 and &lt;tt>strict&lt;/tt> mode.
 * @param {Object} obj
 * Object to inspect.
 * @returns {String}
 * Name of the function used to construct the object.
 */
ObjExt.className = function (obj) {
    let funcNameRegex = /function ([^(]*)/;
    let results = (funcNameRegex).exec((obj).toString());
    return (results &amp;&amp; results.length > 1) ? results[1] : "";
};

/**
 * Creates a copy of the given object. By default the &lt;tt>clone&lt;/tt> function
 * performs a deep copy of the object, passing &lt;tt>deep = false&lt;/tt> will only clone
 * the properties directly owned by the object are transfer to the object includinig
 * &lt;tt>Date&lt;/tt> objects.
 *
 * NOTE: &lt;tt>clone&lt;/tt> is replaceable, &lt;tt>copy&lt;/tt> is not since is a static method.
 * @param {Object} src
 * Reference to the object to be copied.
 * @param {Boolean} [deep=true]
 * Determines if child objects are copied too.
 * @returns {Object}
 * Copy of the object given by &lt;tt>src&lt;/tt>
 */
ObjExt.copy = function (src, deep) {
    if (!src)
        return src;

    // if primitive, just return the value
    if (ObjExt.isPrimitive(src))
        return src.valueOf();

    if (ObjExt.isType(src, Date))
        return new Date(src.getTime());

    if (undefined === deep)
        deep = true;

    let res;
    if (ObjExt.isType(src, Array))
        res = [];
    else
        res = {};

    for (let attr in src) {
        if (src.hasOwnProperty(attr)
            &amp;&amp; null != src[attr] &amp;&amp; "object" == typeof (src[attr])
        ) {
            // Recursion when cloning the Date object fails on return, who knows why...
            // Try it if you don't believe me :)
            if (src[attr] instanceof Date)
                res[attr] = new Date(src[attr].getTime());
            else if (deep)
                res[attr] = ObjExt.copy(src[attr], true);
        }
        else
            res[attr] = src[attr];
    }
    return res;
};

/**
 * Returns true of 'src' fully contains 'tgt'. The comparison is recursive so all
 * properties and children's properties of 'tgt' must also exist in 'src' and have the
 * same values.
 * @param {Object} src
 * @param {Object} tgt
 * @returns {Boolean}
 */
ObjExt.contains = function (src, tgt) {
    for (let k in tgt)
        if (tgt.hasOwnProperty(k)) {

            // If property is tgt missing in src, tgt is not contained
            if (!src.hasOwnProperty(k))
                return false;

            // Compare primitive, 'undefined' or 'null' tgt[k]
            if (ObjExt.isPrimitive(tgt[k]) || !tgt[k]) {
                if (tgt[k] !== src[k])
                    return false;
            }
            // Compare object tgt[k] recursively
            // If source property is not an object tgt is not contained
            else if (ObjExt.isPrimitive(src[k]) || !src[k])
                return false;
            else if (!ObjExt.contains(src[k], tgt[k]))
                return false;

        }

    return true;
};


/**
 * Returns true of the object matches the given type. objType should be a function
 * constructor such as 'Number', 'Date', 'String', etc.
 * @param {Function} objType
 * @returns {Boolean}
 */
ObjExt.prototype.is = function (objType) {
    return ObjExt.isType(this, objType);
};

/**
 * Returns true if this object is one of the primitive types &lt;tt>Number&lt;/tt>,
 * &lt;tt>String&lt;/tt> or &lt;tt>Boolean&lt;/tt>.
 * @returns {Boolean}
 */
ObjExt.prototype.isPrimitive = function () {
    return ObjExt.isPrimitive(this);
};

/**
 * Makes a copy of the current object. All attributes are copied including dates and
 * strings. The returned object has no common references with the original object. If the
 * optional parameter "deep" is set to true, the object is recursively cloned, all
 * aggregated objects and arrays are also cloned.
 * @param deep
 * @returns {Object}
 */
ObjExt.prototype.clone = function (deep)
{
    return Object.copy(this, deep);
};

/**
 * Returns true of 'this' fully contains 'tgt'. The comparison is recursive so all
 * properties and children's properties of 'tgt' must also exist in this' and have the
 * same values.
 * @param {Object} tgt
 * @returns {Boolean}
 */
ObjExt.prototype.contains = function (tgt) {
    return ObjExt.contains(this, tgt);
};

/**
 * Merges the attributes from &lt;b>src&lt;/b> into '&lt;b>this&lt;/b> object. If &lt;b>replace&lt;/b> is
 * true, all overlapping attributes are replaced.
 * NOTE: Recursion when cloning the Date object fails on return, who knows why... try it
 * if you don't believe me :)
 * @param {Object} src
 * @param {Boolean} replace
 * @param {Boolean} deep
 * @returns {Object}
 */
ObjExt.prototype.merge = function (src, replace, deep)
{
    if (undefined === src || null === src)
        return this;

    if (undefined === deep)
        deep = true;

    for (let attr in src) {
        if (src.hasOwnProperty(attr)) {
            if (!src[attr] || ObjExt.isPrimitive(src[attr])) {
                if (undefined === this[attr] || replace)
                    if (src[attr] instanceof Date)
                        this[attr] = new Date(src[attr].getTime());
                    else
                        this[attr] = src[attr];
            }
            else if (deep) {
                if (undefined === this[attr] ||
                    (replace &amp;&amp; ObjExt.isPrimitive(this[attr]))
                )
                    this[attr] = ObjExt.copy(src[attr], true);
                else
                    this[attr].merge(src[attr], replace, true);
            }
        }
    }

    return this;    // allow method to be called on object assignment
};

/**
 * Returns the name of the constructor function that was used to create the instance.
 * @returns {String}
 */
ObjExt.prototype.className = function () {
    return ObjExt.className((this).constructor);
};



// =======================
// == Number Extensions ==
// =======================


/**
 * @alias Number
 * @constructor
 */
function NumExt() {}


/**
 * Rounds the number &lt;b>this&lt;/b> to the given integer amount.
 * @param {Number} amount
 * @returns {Number}
 */
NumExt.prototype.roundToInt = function (amount) {
    return Math.round(this / amount) * amount;
};

/**
 * Truncates the number &lt;b>this&lt;/b> to the given integer amount.
 * @param {Number} amount
 * @returns {number}
 */
NumExt.prototype.truncToInt = function (amount) {
    return Math.floor(this / amount) * amount;
};

/**
 * Calculates the next closest power of 2 number.
 * @returns {Number}
 */
NumExt.prototype.nextPow2 = function () {
    let x = Math.ceil(this);

    x -= 1;
    x |= (x >> 1);
    x |= (x >> 2);
    x |= (x >> 4);
    x |= (x >> 8);
    x |= (x >> 16);

    return x + 1;
};

/**
 * Calculates the previous closest power of 2 number.
 * @returns {Number}
 */
NumExt.prototype.prevPow2 = function () {
    return Number(Math.floor(this) + 1).nextPow2() >> 1;
};

/**
 * Returns a string pre-appending any necessary 0s to reach the given width
 * @param {Number} width
 * @returns {String}
 */
NumExt.prototype.zeroPadd = function (width) {
    let num_str = this.toString();
    let len = width - num_str.length;
    for (let i = 0; i &lt; len; ++i)
        num_str = "0" + num_str;
    return num_str;
};

/**
 * Assumes the input is in milliseconds (straight from dateExt.getTime)
 * Format Specs:
 * &lt;ul>
 *      &lt;li>h[h]    = hours
 *      &lt;li>m[m]    = minutes
 *      &lt;li>s[s]    = seconds
 *      &lt;li>f       = hundreds of a second
 *      &lt;li>ff      = tens of a seconds
 *      &lt;li>fff     = milliseconds
 * &lt;/ul>
 * Text enclosed within {} brackets is excluded from substitution however the brackets
 * are removed. To preserve the braces use double braces: {{test}} = {test}
 * @param {String} [format]
 * @returns {String}
 */
NumExt.prototype.toTime = function (format) {
    if (undefined === format)
        format = "hh:mm:ss";

    let time = Math.abs(this);
    let seconds = time/ 1000;
    let hours = (this >= 0) ?
        Math.floor(seconds / 3600) : -1 * Math.floor(seconds / 3600);
    let minutes = Math.floor((seconds % 3600) / 60);
    seconds = Math.floor(seconds % 60);
    let millis = Math.floor(time% 1000);
    let tens_of_millis = Math.floor(millis / 10);
    let hundreds_of_millis = Math.floor(tens_of_millis / 10);

    return formatTime();

    function formatTime()
    {
        let bits = [];
        let closeSplit = format.split("}");
        for (let i = 0; i &lt; closeSplit.length; ++i)
        {
            let openSplit = closeSplit[i].split("{");

            openSplit[0] = openSplit[0].replace("hh", hours.zeroPadd(2));
            openSplit[0] = openSplit[0].replace("h", hours);

            openSplit[0] = openSplit[0].replace("mm", minutes.zeroPadd(2));
            openSplit[0] = openSplit[0].replace("m", minutes);

            openSplit[0] = openSplit[0].replace("ss", seconds.zeroPadd(2));
            openSplit[0] = openSplit[0].replace("s", seconds);

            openSplit[0] = openSplit[0].replace("fff", millis.zeroPadd(3));
            openSplit[0] = openSplit[0].replace("ff", tens_of_millis.zeroPadd(2));
            openSplit[0] = openSplit[0].replace("f", hundreds_of_millis.zeroPadd(1));

            if (millis > 0)
                openSplit[0] = openSplit[0].replace("FFF", millis);
            if (tens_of_millis > 0)
                openSplit[0] = openSplit[0].replace("FF", tens_of_millis);
            if (hundreds_of_millis > 0)
                openSplit[0] = openSplit[0].replace("F", hundreds_of_millis);

            bits.push(openSplit.join(""));
        }

        return bits.join("");
    }
};

/**
 * Returns a string with the number as an enumeration (1st, 2nd, 3rd, 4th, etc)
 * @returns {String}
 */
NumExt.prototype.toEnum = function () {
    let val = Math.abs(Number(this));
    if (1 == val) return this + "st";
    if (2 == val) return this + "nd";
    if (3 == val) return this + "rd";
    return this + "th";

};

/**
 * Returns true if the number is within the given range. By default the range is
 * interpreted as a close range, passing 'inclusive = false' will make it an open range.
 * @param {Number} first
 * @param {Number} second
 * @param {Boolean} inclusive
 * @returns {Boolean}
 */
NumExt.prototype.between = function (first, second, inclusive)
{
    if (isNaN(first) || isNaN(second))
        throw new Error("Invalid cal to \"between\", the input parameters must " +
            "be numeric.");

    first = Number(first);
    second = Number(second);

    let low = Math.min(first, second);
    let high = Math.max(first, second);

    if (undefined === inclusive || inclusive)
        return (this >= low &amp;&amp; this &lt;= high);

    return (this > low &amp;&amp; this &lt; high);
};



// ===================
// ==Date Extensions==
// ===================

/**
 * @alias Date
 * @constructor
 */
function DateExt() {}


/**
 * Formats the given date "dt" using the formatting specifications in fstr. The following
 * formatting tokens apply:
 *  &lt;table style="width: 100%">
 *      &lt;tr>&lt;/td>&lt;td>&lt;b>yyyy&lt;/b>&lt;/td>&lt;td style="width: 6px">&lt;/td>&lt;td>Four digit year&lt;/td>&lt;/tr>
 *      &lt;tr>&lt;td>&lt;b>yy&lt;/b>&lt;/td>&lt;td>&lt;/td>&lt;td>Two digit year&lt;/td>&lt;/tr>
 *      &lt;tr>&lt;td>&lt;b>MM&lt;/b>&lt;/td>&lt;td>&lt;/td>&lt;td>Two digit month&lt;/td>&lt;/tr>
 *      &lt;tr>&lt;td>&lt;b>M&lt;/b>&lt;/td>&lt;td>&lt;/td>&lt;td>Single digit month (when less than 10)&lt;/td>&lt;/tr>
 *      &lt;tr>&lt;td>&lt;b>MMMM&lt;/b>&lt;/td>&lt;td>&lt;/td>&lt;td>Month of the year, full name&lt;/td>&lt;/tr>
 *      &lt;tr>&lt;td>&lt;b>MMM&lt;/b>&lt;/td>&lt;td>&lt;/td>&lt;td>Month of the year, short name&lt;/td>&lt;/tr>
 *      &lt;tr>&lt;td>&lt;b>dd&lt;/b>&lt;/td>&lt;td>&lt;/td>&lt;td>Two digit day&lt;/td>&lt;/tr>
 *      &lt;tr>&lt;td>&lt;b>d&lt;/b>&lt;/td>&lt;td>&lt;/td>&lt;td>Single digit day (when less than 10)&lt;/td>&lt;/tr>
 *      &lt;tr>&lt;td>&lt;b>dddd&lt;/b>&lt;/td>&lt;td>&lt;/td>&lt;td>Day of the week, full name&lt;/td>&lt;/tr>
 *      &lt;tr>&lt;td>&lt;b>ddd&lt;/b>&lt;/td>&lt;td>&lt;/td>&lt;td>Day of the week, short name&lt;/td>&lt;/tr>
 *      &lt;tr>&lt;td>&lt;b>HH&lt;/b>&lt;/td>&lt;td>&lt;/td>&lt;td>Two digit hour, 24 hour clock&lt;/td>&lt;/tr>
 *      &lt;tr>&lt;td>&lt;b>H&lt;/b>&lt;/td>&lt;td>&lt;/td>&lt;td>Single digit hour (when less than 10), 24 hour clock&lt;/td>&lt;/tr>
 *      &lt;tr>&lt;td>&lt;b>hh&lt;/b>&lt;/td>&lt;td>&lt;/td>&lt;td>Two digit hour, 12 hour clock&lt;/td>&lt;/tr>
 *      &lt;tr>&lt;td>&lt;b>h&lt;/b>&lt;/td>&lt;td>&lt;/td>&lt;td>Single digit hour (when less than 10), 12 hour clock&lt;/td>&lt;/tr>
 *      &lt;tr>&lt;td>&lt;b>TT&lt;/b>&lt;/td>&lt;td>&lt;/td>&lt;td>Time of day (AM/PM)&lt;/td>&lt;/tr>
 *      &lt;tr>&lt;td>&lt;b>T&lt;/b>&lt;/td>&lt;td>&lt;/td>&lt;td>Time of day (A/P)&lt;/td>&lt;/tr>
 *      &lt;tr>&lt;td>&lt;b>tt&lt;/b>&lt;/td>&lt;td>&lt;/td>&lt;td>Time of day in lowercase (am/pm)&lt;/td>&lt;/tr>
 *      &lt;tr>&lt;td>&lt;b>t&lt;/b>&lt;/td>&lt;td>&lt;/td>&lt;td>Time of day in lowercase (a/b)&lt;/td>&lt;/tr>
 *      &lt;tr>&lt;td>&lt;b>mm&lt;/b>&lt;/td>&lt;td>&lt;/td>&lt;td>Two digit minute&lt;/td>&lt;/tr>
 *      &lt;tr>&lt;td>&lt;b>m&lt;/b>&lt;/td>&lt;td>&lt;/td>&lt;td>Single digit minute (when less than 10)&lt;/td>&lt;/tr>
 *      &lt;tr>&lt;td>&lt;b>ss&lt;/b>&lt;/td>&lt;td>&lt;/td>&lt;td>Two digit second&lt;/td>&lt;/tr>
 *      &lt;tr>&lt;td>&lt;b>s&lt;/b>&lt;/td>&lt;td>&lt;/td>&lt;td>Single digit second (when less than 10)&lt;/td>&lt;/tr>
 *      &lt;tr>&lt;td>&lt;b>fff&lt;/b>&lt;/td>&lt;td>&lt;/td>&lt;td>Milliseconds, zero padded 3 digit number&lt;/td>&lt;/tr>
 *      &lt;tr>&lt;td>&lt;b>ff&lt;/b>&lt;/td>&lt;td>&lt;/td>&lt;td>Tens of milliseconds, zero padded 2 digit number&lt;/td>&lt;/tr>
 *      &lt;tr>&lt;td>&lt;b>f&lt;/b>&lt;/td>&lt;td>&lt;/td>&lt;td>Hundreds of milliseconds&lt;/td>&lt;/tr>
 *      &lt;tr>&lt;td>&lt;b>FFF&lt;/b>&lt;/td>&lt;td>&lt;/td>&lt;td>Milliseconds with no padding&lt;/td>&lt;/tr>
 *      &lt;tr>&lt;td>&lt;b>FF&lt;/b>&lt;/td>&lt;td>&lt;/td>&lt;td>Tens of milliseconds, with no padding&lt;/td>&lt;/tr>
 *      &lt;tr>&lt;td>&lt;b>F&lt;/b>&lt;/td>&lt;td>&lt;/td>&lt;td>Hundreds of milliseconds, with no padding&lt;/td>&lt;/tr>
 *      &lt;tr>&lt;td>&lt;b>KKK&lt;/b>&lt;/td>&lt;td>&lt;/td>&lt;td>Timezone long description > GMT-0700 (PDT)&lt;/td>&lt;/tr>
 *      &lt;tr>&lt;td>&lt;b>KK&lt;/b>&lt;/td>&lt;td>&lt;/td>&lt;td>Timezone short description > PDT&lt;/td>&lt;/tr>
 *      &lt;tr>&lt;td>&lt;b>K&lt;/b>&lt;/td>&lt;td>&lt;/td>&lt;td>Timezone offset from GMT > -0700&lt;/td>&lt;/tr>
 *  &lt;/table>
 *
 * Use the "{" and "}" brackets to enclose text where date substitution should be avoided.
 * @param {Date} dt Instance of &lt;tt>date&lt;/tt> to format.
 * @param {String} fstr Format string, e.g. "yyyy/MM/dd"
 * @param {Function} [replacer] Optional function to replace the date/time tokens. If
 * omitted, the default substitution is used.
 * @returns {String}
 */
DateExt.format = function (dt, fstr, replacer)
{
    if (!replacer || !ObjExt.isType(replacer, Function))
        replacer = function () { return null; };

    if (undefined === fstr)
        fstr = "MM/dd/yyyy hh:mm:ss";

    // First resolve all name related tokens and enclose within {} to avoid the
    // token substitution from affecting the month and day of week names.

    fstr = protectEscapedChars(fstr);
    fstr = resolveNames(dt, fstr);

    let h12 = (dt.getHours() > 12) ? dt.getHours() - 12 : dt.getHours();
    let millis = dt.getMilliseconds();
    let tens_of_millis = Math.round(millis / 10);
    let hundreds_of_millis = Math.round(tens_of_millis / 10);

    let bits = [];
    let closeSplit = fstr.split("}");
    for (let i = 0; i &lt; closeSplit.length; ++i)
    {
        let openSplit = closeSplit[i].split("{");

        // Long tokens first to avoid partial match substitution
        openSplit[0] = openSplit[0].replace("yyyy", replacer(dt, "yyyy") ||
            dt.getFullYear());
        openSplit[0] = openSplit[0].replace("yy", replacer(dt, "yy") ||
            dt.getYear());

        openSplit[0] = openSplit[0].replace("MM", replacer(dt, "MM") ||
            (dt.getMonth() + 1).zeroPadd(2));
        openSplit[0] = openSplit[0].replace("M", replacer(dt, "M") ||
            (dt.getMonth() + 1));

        openSplit[0] = openSplit[0].replace("dd", replacer(dt, "dd") ||
            dt.getDate().zeroPadd(2));
        openSplit[0] = openSplit[0].replace("d", replacer(dt, "d") ||
            dt.getDate());

        openSplit[0] = openSplit[0].replace("HH", replacer(dt, "HH") ||
            dt.getHours().zeroPadd(2));
        openSplit[0] = openSplit[0].replace("H", replacer(dt, "H") ||
            dt.getHours());
        openSplit[0] = openSplit[0].replace("hh", replacer(dt, "hh") ||
            h12.zeroPadd(2));
        openSplit[0] = openSplit[0].replace("h", replacer(dt, "h") ||
            h12);

        openSplit[0] = openSplit[0].replace("mm", replacer(dt, "mm") ||
            dt.getMinutes().zeroPadd(2));
        openSplit[0] = openSplit[0].replace("m", replacer(dt, "m") ||
            dt.getMinutes());

        openSplit[0] = openSplit[0].replace("ss", replacer(dt, "ss") ||
            dt.getSeconds().zeroPadd(2));
        openSplit[0] = openSplit[0].replace("s", replacer(dt, "s") ||
            dt.getSeconds());

        openSplit[0] = openSplit[0].replace("fff", replacer(dt, "fff") ||
            millis.zeroPadd(3));
        openSplit[0] = openSplit[0].replace("ff", replacer(dt, "ff") ||
            tens_of_millis.zeroPadd(2));
        openSplit[0] = openSplit[0].replace("f", replacer(dt, "f") ||
            hundreds_of_millis.zeroPadd(1));

        openSplit[0] = openSplit[0].replace("FFF", replacer(dt, "FFF") ||
            millis);
        openSplit[0] = openSplit[0].replace("FF", replacer(dt, "FF") ||
            tens_of_millis);
        openSplit[0] = openSplit[0].replace("F", replacer(dt, "F") ||
            hundreds_of_millis);

        bits.push(openSplit.join(""));
    }

    return replaceTokens(bits.join(""));

    function protectEscapedChars(str)
    {
        str = str.replace(/{{/g, "{:OBRACKET:}");
        str = str.replace(/}}/g, "{:CBRACKET:}");
        return str;
    }

    function replaceTokens(str)
    {
        str = str.replace(/:OBRACKET:/g, "{", "g");
        str = str.replace(/:CBRACKET:/g, "}", "g");
        return str;
    }

    function resolveNames(dt, fstr)
    {
        let dow = [
            "Sunday",       "Monday",       "Thuesday",     "Wednesday",
            "Thursday",     "Friday",       "Saturday"];
        let dow_short = [
            "Sun", "Mon", "Tue", "Wed",
            "Thu", "Fri", "Sat"];
        let month = [
            "January",      "Februaty",     "March",        "April",        "May",
            "June",         "July",         "August",       "September",    "October",
            "November",     "December"];
        let month_short = [
            "Jan", "Feb", "Mar", "Apr", "May", "Jun",
            "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];

        let bits = [];
        let closeSplit = fstr.split("}");
        let pm = (dt.getHours() >= 12);
        for (let i = 0; i &lt; closeSplit.length; ++i)
        {
            let openSplit = closeSplit[i].split("{");

            openSplit[0] = openSplit[0].replace("TT", "{" + (replacer(dt, "tt") ||
                (pm ? "PM" : "AM")) + "}");
            openSplit[0] = openSplit[0].replace("T", "{" + (replacer(dt, "t") ||
                (pm ? "P" : "A")) + "}");
            openSplit[0] = openSplit[0].replace("tt", "{" + (replacer(dt, "tt") ||
                (pm ? "pm" : "am")) + "}");
            openSplit[0] = openSplit[0].replace("t", "{" + (replacer(dt, "t") ||
                (pm ? "p" : "a")) + "}");

            openSplit[0] = openSplit[0].replace("MMMM", "{" + (replacer(dt, "MMMM") ||
                month[dt.getMonth()]) + "}");
            openSplit[0] = openSplit[0].replace("MMM", "{" + (replacer(dt, "MM") ||
                month_short[dt.getMonth()]) + "}");

            openSplit[0] = openSplit[0].replace("dddd", "{" + (replacer(dt, "dddd") ||
                dow[dt.getDay()]) + "}");
            openSplit[0] = openSplit[0].replace("ddd", "{" + (replacer(dt, "ddd") ||
                dow_short[dt.getDay()]) + "}");

            // TODO : Timezone replacement has not yet been implemented.
            openSplit[0] = openSplit[0].replace("KKK", "{" + (replacer(dt, "KKK") ||
                "KKK") + "}");
            openSplit[0] = openSplit[0].replace("KK", "{" + (replacer(dt, "KK") ||
                "KK") + "}");
            openSplit[0] = openSplit[0].replace("K", "{" + (replacer(dt, "K") ||
                "K") + "}");

            bits.push(openSplit.join("{"));
        }

        return bits.join("}");
    }
};

/**
 * Compares the two dates and returns true if they point to the same day.
 * @param {Date} date1 First date to compare.
 * @param {Date} date2 Second date to compare.
 * @returns {Boolean}
 */
DateExt.sameDay = function (date1, date2)
{
    return date1.getFullYear() == date2.getFullYear()
        &amp;&amp; date1.getMonth() == date2.getMonth()
        &amp;&amp; date1.getDate() == date2.getDate();
};

/**
 * Returns the maximum length that the given format string can yield after a date is
 * formatted.
 * Usage:
 * &lt;ul>
 *      &lt;li>&lt;tt>let len = DateExt.formatLength("yyyy/mm/dd");  // len = 10&lt;/tt>
 *      &lt;li>&lt;tt>let len = DateExt.formatLength("yyy/m/d");     // len = 10&lt;/tt>
 * &lt;/ul>
 * @param {String} format_str
 * @param {Function} [replacer] Function to replace date/time tokens.
 * @returns {Number}
 */
DateExt.formatLength = function (format_str, replacer)
{
    // using a date that has 2 digit month, day, hour, minute and second,
    // and 3 digits for milliseconds that won't round to zero when doing
    // tens or hundreds of millis.
    let full_date = new Date(2015, 10, 17, 12, 45, 45, 123);
    return full_date.format(format_str, replacer).length;
};


// == Instance Members ==

/**
 * Returns copy of &lt;tt>this&lt;/tt> and adds &lt;tt>y&lt;/tt> number of years to it. The number of
 * years to add can be negative.
 * @param {Number} [y=1] Number of years to add.
 * @returns {Date} Returns a new instance of &lt;tt>Date&lt;/tt>.
 */
DateExt.prototype.addYears = function (y)
{
    if (isNaN(y)) y = 1;
    return new Date(
        this.getFullYear() + y, this.getMonth(), this.getDate(),
        this.getHours(), this.getMinutes(), this.getSeconds(), this.getMilliseconds()
    );
};

/**
 * Adds &lt;tt>y&lt;/tt> number of years to &lt;tt>this&lt;/tt> and returns it to allow chaining.
 * @param {Number} [y=1] Number of years to add.
 * @returns {Date} Returns &lt;tt>this&lt;/tt> after incrementing it's value.
 */
DateExt.prototype.incYear = function (y)
{
    if (isNaN(y)) y = 1;
    this.setFullYear(this.getFullYear() + y);
    return this;
};

/**
 * Returns copy of &lt;tt>this&lt;/tt> and adds &lt;tt>m&lt;/tt> number of months to it. The number of
 * months can be negative.
 * @param {Number} [m=1] Number of months to add.
 * @returns {Date} Returns a new instance of &lt;tt>Date&lt;/tt>.
 */
DateExt.prototype.addMonths = function (m)
{
    if (isNaN(m)) m = 1;
    let res = new Date(this.getTime());
    res.setMonth(res.getMonth() + m);
    return res;
};

/**
 * Adds &lt;b>m&lt;/b> number of months to &lt;b>this&lt;/b> and returns it to allow chaining.
 * @param {Number} [m=1] Number of months to add.
 * @returns {Date} Returns &lt;tt>this&lt;/tt> after incrementing it's value.
 */
DateExt.prototype.incMonth = function (m)
{
    if (isNaN(m)) m = 1;
    this.setMonth(this.getMonth() + m);
};

/**
 * Returns copy of &lt;b>this&lt;/b> and adds &lt;b>d&lt;/b> number of days to it. The number of days
 * can be negative.
 * @param {Number} [d=1] Number of days to add.
 * @returns {Date} Returns a new instance of &lt;tt>Date&lt;/tt>.
 */
DateExt.prototype.addDays = function (d)
{
    if (isNaN(d)) d = 1;
    return new Date(this.getTime() + (d * 36e5 * 24));
};

/**
 * Adds &lt;tt>d&lt;/tt> number of days to &lt;tt>this&lt;/tt> and returns it to allow chaining.
 * @param {Number} [d=1] Number of days to add.
 * @returns {Date} Returns &lt;tt>this&lt;/tt> after incrementing it's value.
 */
dateExt.incDay = function (d)
{
    if (isNaN(d)) d = 1;
    this.setTime(this.getTime() + (d * 36e5 * 24));
};

/**
 * Returns copy of &lt;tt>this&lt;/tt> and adds &lt;tt>h&lt;/tt> number of hours to it.
 * @param {Number} [h=1] Number of hours to add.
 * @returns {Date} Returns a new instance of &lt;tt>Date&lt;/tt>.
 */
dateExt.addHours = function (h)
{
    if (isNaN(h)) h = 1;
    return new Date(this.getTime() + (h * 36e5));
};

/**
 * Adds &lt;tt>h&lt;/tt> number of hours to &lt;tt>this&lt;/tt> and returns it to allow chaining.
 * @param {Number} [h=1] Number of hours to add.
 * @returns {Date} Returns &lt;tt>this&lt;/tt> after incrementing it's value.
 */
DateExt.prototype.incHour = function (h)
{
    if (isNaN(h)) h = 1;
    this.setTime(this.getTime() + (h * 36e5));
};

/**
 * Returns copy of &lt;tt>this&lt;/tt> and adds &lt;tt>m&lt;/tt> number of minutes to it. The number
 * of minutes can be negative.
 * @param {Number} [m=1] Number of minutes to add.
 * @returns {Date} Returns a new instance of &lt;tt>Date&lt;/tt>.
 */
DateExt.prototype.addMinutes = function (m)
{
    if (isNaN(m)) m = 1;
    return new Date(this.getTime() + (m * 6e4));
};

/**
 * Adds &lt;tt>h&lt;/tt> number of minutes to &lt;tt>this&lt;/tt> and returns it to allow chaining.
 * @param {Number} [m=1] Number of minutes to add.
 * @returns {Date} Returns &lt;tt>this&lt;/tt> after incrementing it's value.
 */
DateExt.prototype.incMinute = function (m)
{
    if (isNaN(m)) m = 1;
    this.setTime(this.getTime() + (m * 6e4));
};

/**
 * Returns copy of &lt;tt>this&lt;/tt> and adds &lt;tt>d&lt;/tt> number of seconds to it. The number of
 * seconds can be negative.
 * @param {Number} [s=1] Number of seconds to add.
 * @returns {Date} Returns a new instance of &lt;tt>Date&lt;/tt>.
 */
DateExt.prototype.addSeconds = function (s)
{
    if (isNaN(s)) s = 1;
    return new Date(this.getTime() + (s * 1000));
};

/**
 * Adds &lt;tt>h&lt;/tt> number of seconds to &lt;tt>this&lt;/tt> and returns it to allow chaining.
 * @param {Number} [s=1] Number of seconds to add.
 * @returns {Date} Returns &lt;tt>this&lt;/tt> after incrementing it's value.
 */
DateExt.prototype.incSecond = function (s)
{
    if (isNaN(s)) s = 1;
    return this.setTime(this.getTime() + (s * 1000));
};

/**
 * Returns copy of &lt;tt>this&lt;/tt> and adds &lt;tt>d&lt;/tt> number of milliseconds to it. The number
 * of milliseconds can be negative.
 * @param {Number} [ms=1] Number of milliseconds to add.
 * @returns {Date} Returns a new instance of &lt;tt>Date&lt;/tt>.
 */
DateExt.prototype.addMillis = function (ms)
{
    if (isNaN(ms)) ms = 1;
    return new Date(this.getTime() + ms);
};

/**
 * Adds &lt;tt>h&lt;/tt> number of milliseconds to &lt;tt>this&lt;/tt> and returns it to allow
 * chaining.
 * @param {Number} [ms=1] Number of milliseconds to add.
 * @returns {Date} Returns &lt;tt>this&lt;/tt> after incrementing it's value.
 */
DateExt.prototype.incMilli = function (ms)
{
    if (isNaN(ms)) ms = 1;
    return this.setTime(this.getTime() + ms);
};

/**
 * Returns the difference between &lt;tt>this&lt;/tt> and &lt;tt>date&lt;/tt> in the given units
 * (milliseconds by default). Supported units are: "day/d", "hour/h", "minute/m",
 * "second/s", "millisecond/msec/f"
 * @param {Date} date The date to compare against
 * @param {String} units Units to compare (day, hour, minute, second, msec).
 * @returns {Number} Returns the difference between the two dates.
 * @throws Throws an error if &lt;tt>units&lt;/tt> are not supported.
 */
DateExt.prototype.diff = function (date, units)
{
    if (!ObjExt.isType(date, Date))
        throw new Error("Invalid call to 'Date.diff', the input is not " +
            "a data.");
    if (!units)
        units = "f";

    if (units === "f" || units === "millisecond" || units === "msec")
        return Math.floor(Math.abs(date.getTime() - this.getTime()));

    if (units === "s" || units === "second")
        return Math.floor(Math.abs(date.getTime() - this.getTime()) / 1000);

    if (units === "m" || units === "minute")
        return Math.floor(Math.abs(date.getTime() - this.getTime()) / 6e4);

    if (units === "h" || units === "hour")
        return Math.floor(Math.abs(date.getTime() - this.getTime()) / 36e6);

    if (units === "d" || units === "day")
        return Math.floor(Math.abs(date.getTime() - this.getTime()) / (36e6 * 24));

    throw new Error("The '" + units + "' units are not supported.");
};

/**
 * Returns a new date object representing the same date/time but in UTC. This is a nasty
 * hack since the returned date still shows the local timezone (no way to change this as
 * far as I know), however it is very convenient to be able to operate on a Date that's
 * already adjusted.
 * @returns {Date}
 */
DateExt.prototype.toUtc = function ()
{
    return new Date(this.getTime() + this.getTimezoneOffset() * 60000);
};


/**
 // Formats the date with the given specification. See &lt;tt>Date.format&lt;/tt> for more
 detail.
 * @param {String} fstr Format string in the form &lt;code>yyyy/MM/dd&lt;/code>
 * @param {Function} [replacer] Optional function to replace the date/time tokens.
 * @returns {string} Returns a string with the formatted date/time
 */
DateExt.prototype.format = function (fstr, replacer)
{
    return DateExt.format(this, fstr, replacer);
};

/**
 * Returns true if &lt;tt>this&lt;/tt> and &lt;tt>date&lt;/tt> point to the same day.
 * @param {Date} date
 * @returns {Boolean}
 */
DateExt.prototype.sameDay = function (date)
{
    return DateExt.sameDay(this, date);
};

/**
 * Returns true if &lt;tt>this&lt;/tt> day is earlier than &lt;tt>date&lt;/tt> ignoring the time.
 * @param {Date} date
 * @returns {Boolean}
 */
DateExt.prototype.earlierDayThan = function (date)
{
    if (this.getFullYear() &lt; date.getFullYear())
        return true;
    else if (this.getFullYear() > date.getFullYear())
        return false;

    if (this.getMonth() &lt; date.getMonth())
        return true;
    else if (this.getMonth() > date.getMonth())
        return false;

    return (this.getDate() &lt; date.getDate());
};

/**
 * Returns true if &lt;b>this&lt;/b> day is later than &lt;b>date&lt;/b> ignoring the time.
 * @param {Date} date
 * @returns {Boolean}
 */
DateExt.prototype.laterDayThan = function (date)
{
    return date.earlierDayThan(this);
};

/**
 * Zeros out the time component of &lt;tt>this&lt;/tt>.
 * @returns {DateExt} Returns &lt;tt>this&lt;/tt> after truncating time.
 */
DateExt.prototype.truncTime = function () {
    this.setHours(0, 0, 0, 0);
    return this;
};



// ======================
// == Array Extensions ==
// ======================

/**
 * @alias Array
 * @constructor
 */
function ArrayExt() {}

// == Instance Members ==

/**
 * Returns the first element in the array. The optional offset parameter can be used to
 * iterate through the array from first to last.
 * @param {Number} [offset=0]
 * Optionally returns the element &lt;tt>offset&lt;/tt> from the first.
 * @returns {*}
 */
ArrayExt.prototype.first = function (offset)
{
    if (!offset)
        offset = 0;

    if (this.length &lt;= offset)
        return null;

    return this[offset];
};

/**
 * Returns the last element in the array. The optional offset parameter can be used to
 * iterate through the array from last to first.
 * @param {Number} [offset=0]
 * Optionally returns the element &lt;tt>offset&lt;/tt> from the last.
 * @returns {*}
 */
ArrayExt.prototype.last = function (offset)
{
    if (!offset)
        offset = 0;

    if (this.length &lt;= offset)
        return null;

    return this[this.length - 1 - offset];
};

/**
 * Returns &lt;tt>true&lt;/tt> if the given index points to the last element in the
 * &lt;tt>Array&lt;/tt>.
 * @param {Number} index
 * @returns {Boolean}
 */
ArrayExt.prototype.isLast = function (index) {
    return ((index + 1) === this.length);
};

/**
 * Returns &lt;tt>true&lt;/tt> if the array has no elements.
 * @returns {Boolean}
 */
ArrayExt.prototype.empty = function ()
{
    return this.length == 0;
};





// ===============

function registerExtension(orig, ext) {
    for (let k in ext)
        if (ext.hasOwnProperty(k)) {
            if (orig.hasOwnProperty(k))
                continue;

            Object.defineProperty(orig, k, {value: ext[k], writable: true});
        }

    if (ext.prototype &amp;&amp; orig.prototype)
        registerExtension(orig.prototype, ext.prototype)
}

module.exports = {
    /**
     * Register the extensions for the given object type, or all extensions if no
     * specific type is provided. Currently only &lt;tt>Object&lt;/tt>, &lt;tt>Number&lt;/tt>,
     * &lt;tt>Date&lt;/tt> and &lt;tt>Array&lt;/tt> are supported.
     * @param {Function} [targets...]
     * The constructor function of the object to extend.
     */
    init: function (targets) {
        let args = Array.prototype.slice.call(arguments);

        if (hasType(Object))    registerExtension(Object, ObjExt);
        if (hasType(Number))    registerExtension(Number, NumExt);
        if (hasType(Date))      registerExtension(Date, DateExt);
        if (hasType(Array))     registerExtension(Array, ArrayExt);


        function hasType(type) {
            "use strict";
            if (0 === args.length)
                return true;

            for (let i = 0; i &lt; args.length; i++)
                if (args[i] === type)
                    return true;

            return false;
        }
    }
};

</code></pre>
        </article>
    </section>




</div>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.4.3</a> on Mon, 17 Apr 2017 16:56:01 GMT using
    <a href="https://www.npmjs.com/package/namis">Namis</a> theme.
</footer>

<script src="https://code.jquery.com/jquery-1.11.3.min.js"></script>
<script src="https://cdn.jsdelivr.net/jquery.nicescroll/3.6.0/jquery.nicescroll.min.js"></script>
<script src="scripts/namis.search.jquery.js"></script>
<script>prettyPrint();
(function($){
    $('nav').niceScroll({
        cursorwidth: 7,
        hwacceleration: true,
        cursorcolor: "#036564",
        cursorborder: "1px solid #036564"
    });

    $('html').niceScroll({
        cursorwidth: 10,
        hwacceleration: true,
        smoothscroll: true,
        cursorminheight: 32,
        enablemousewheel: true, // nicescroll can manage mouse wheel events
        enablekeyboard: true // nicescroll can manage keyboard events
        ,cursorcolor: "#033649"
    });

    $('#nav').search(['className', 'methodName']);
})(jQuery);
</script>
<script src="scripts/linenumber.js"></script>
</body>
</html>
